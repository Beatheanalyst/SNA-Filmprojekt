---
title: "Zusammenfassung_Testat.rmd"
author: "Alice K√§rcher"
date: "2023-12-11"
output: html_document
---

#Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) #bei knit zu HTML wird Code mit ausgespielt

# Notwendige Bibliotheken
library(tidyverse)
library(igraph)

```

#Basics Caution

**Was brauche ich f√ºr die Pr√ºfungsleistung?**

##Accountdaten 

**Github:** 
- [ ] HdM-Mailadresse
- [ ] Passwort: Ha21uB0022!   
- [ ] Username: ak349hdm

**Flourish:** 
- [ ] HdM-Mailadresse 
- [ ] Username: ak349hdm 
- [ ] Name: Alice K√§rcher 
- [ ] Passwort: FAl0ur1sh2223!

**Trello**
- [ ] HdM Adresse 
- [ ] Nutzername: Alice K√§rcher 
- [ ] Passwort: crossmedi@1349

--> Link zum Trello-Board R-Testat: https://trello.com/b/qd6KEjpg/r-testatüë©üèªüíªüçÄ


##Zeitplanung

**Testat √∂ffnet: 10:10 Uhr**

**Testat schlie√üt: 11:20 Uhr**

-->**Teil 1 / Wissensfragen**: 12 min ‚Üí bis 10:20 Uhr schreiben, 2 min Korrektur ‚Üí **Abgabe 10:22 Uhr**

-->**Teil 2 / Netzwerkanalyse**: 55 min (45 min schreiben) ‚Üí bis 11:10 Uhr schreiben, bis 11:15 Uhr Korrektur ‚Üí **Abgabe 11:18 Uhr sp√§testens**

##Installation von Programmbibliotheken 

**Code f√ºr R-Chunk**
install.packages(c("tidyverse","rmarkdown","knitr","igraph","snahelper", "tidygraph", "ggraph"))

## Checkliste f√ºr vollst√§ndiges Dokument
-->Name/Datum/K√ºrzel etc. oben im YAML-Header √§ndern
-->**Code annotieren** mit #
-->**Antworts√§tze** schreiben: entweder im Chunk oder in daf√ºr vorgesehenem Textfeld-->eher im daf√ºr vorgesehenen Textfeld, f√ºr mich aber schonmal mit #Annotation im Chunk
-->bei Antworts√§tzen immer darauf beziehen, welche Aufgabe wir meinen, also 1 a) etc.
-->auch, wenn z.B. **Interpretation der Visualisierung** gefragt: in Textfeld au√üerhalb des Chunk & f√ºr mich nur zur Orientierung mit #Annotationen im Chunk
-->am Anfang immer nochmal Environment l√∂schen-->Besen im Environment

## Tipps:
-->f√ºr die extra Caution: Dokument nicht nur **Save**, sondern zwischendurch auch **Save As**, um ganz sicher zu gehen, dass noch Datei da, f√ºr den Fall, dass etwas schief geht
-->wenn ich Chunk kopiere: auch immer beschriften & immer die drei Anfangs- & Endstriche mit kopieren!!!
-->wenn **HTML-Datei auch noch gefragt, dann am besten von Anfang** an **Knit on Save** oder nur auf **Knit** gehen mit aktivieren
-->genauestens auf **Fehlermeldungen in Console** achten & **Fehler finden**, damit es auch reibungslos **knittet**
-->darauf achten, dass **alles richtig geschrieben** ist und **alle Datens√§tze richtig eingelesen** sind!!!
-->wenn Zweck eines Befehls vergessen, kann ich Hilfsfunktion von RStudio nutzen mit **help(Befehl)** oder **?Befehl** / **??Befehl**
-->**Codebuch genaustens angucken**: Namen der Variablen sind genauestens definiert!!!!
-->**Codebuch** am besten in einem **Browser-Fenster** offen lassen!!!
-->wenn ganzer Code als fehlerhaft angezeigt wird-->**in Console gucken, in welcher Zeile genau Error** liegt
-->Mustervorlagen rauskopieren
-->**mit #Annotation erkl√§ren**, was wir machen wollten, wenn es nicht geklappt hat: Chance auf Teilpunkte
-->**Musterl√∂sungen der anderen Aufgabenstellungen parallel offen haben f√ºr Copy/Paste**
-->im Zweifel ChatGPT genau die Aufgabenstellung von Sandhu reinkopieren, Chunk dann in RStudio rauskopieren & dann mit Werten der Aufgabe anpassen
-->wenn Fehlermeldung & Ausf√ºhrung funktioniert nicht: in # dazu annotieren, dass gerade Fehlermeldung und wir erkl√§ren jetzt, wie wir eigentlich weiter vorgehen w√ºrden
-->immer Leerzeile (wei√ü Textfeld) zwischen Chunks
-->am besten **f√ºr jede Aufgabe eigenen Chunk**
-->Befehlsketten in eigenen Zeilen
-->Daten-Variable, z.B. students, am Ende nochmal hinschreiben & ausf√ºhren/runnen, damit Ergebnisse angezeigt werden



# Prompten mit ChatGPT

-->Der Prompt und die Ausgabe m√ºssen im Dokument angegeben werden.
-->Sobald Sie ChatGPT oder Bard oder ein anderes gen KI Tool verwenden, muss dieses dokumentiert werden mit 
  a) generellem Prompt, 
  b) spezifischem Prompt und 
  c) Ergebnis.
Das unmittelbare Ergebnis k√∂nnen Sie im Codechunk wie folgt annotieren
**#Code von ChatGPT / oder X /, Prompt im Anhang 1**
Im Anhang hinterlegen Sie den gesamten Prompt

-->Im Chunk-Chunk direkt annotiert:
 # dieser Code wurde mit ChatGPT erstellt, prompt und Ausgabe in der Anlage (1)
 
 # dieser Code wurde mit ChatGPT erstellt, prompt und Ausgabe in der Anlage (1)
Anhang 
Genereller Prompt f√ºr XX (Initiale Beschreibung der Kompetenzen) 
1 Prompt und Code
2 Prompt und Code

--> Prompt mit angeben 
--> in Code in einer Annotation mit angeben, dass man mit ChatGPT gearbeitet hat
--> den Prompt, den man verwendet hat, in einer Annotation ebenfalls mit angeben

**Prompt ChatGPT f√ºr gute Ergebnisse**

**M√∂glichkeit 1: gibt auch schon Quellenanagabe ChatGPT mit an**

Hallo, ich bin XY. Mein HdM-K√ºrzel ist ab123. 

Du bist ein Experte f√ºr soziale Netzwerkanalyse und verwendest daf√ºr ausschlie√ülich die Programmiersprache R. Unsere bevorzugten Programmbibliotheten sind tidyverse, igraph. Du hilfst Studierenden bei ihren Projekten und sprichst in einer einfachen, direkten Sprache.

Du kannst Code in Markdown erstellen und beim Verst√§ndnis des Codes weiterhelfen. Bitte annotiere Deinen Code entsprechend und trenne Codechunks von Interpretation. Bitte gib auch an, welchen Code oder welches Programmpaket Du gerade zur L√∂sung verwendest. Bereite den Code mit Annotationen so vor, dass ich ihn weiter kopieren kann. Bitte schreibe unter den Code: "Erstellt mit Hilfe von ChatGPT, Deiner Version und bitte gib dann meinen Namen und mein HdM-K√ºrzel an, wenn ich vorher angegeben habe". Bitte gibt auch das aktuelle Datum an, an dem der Code erstellt wurde.  

Erkl√§re die Funktion der einzelnen Befehle und Argumente mit einem Beispiel. Verwende nach M√∂glichkeit ein Standardbeispiel f√ºr die Netzwerkanalyse, das allgemein zug√§nglich. 

Frage nach, ob mein Problem gel√∂st wurde. Vielen Dank!

(Nur f√ºr Expert:innen: Du kannst auch die Pakete, tidygraph, ggraph, ggnet, statnet oder xucinet f√ºr die Netzwerkanalyse verwenden: entscheide selbst, welches Paket am besten funktioniert. 


**M√∂glichkeit 2**: 
Du bist ein Experte f√ºr soziale Netzwerkanalyse und verwendest daf√ºr ausschlie√ülich die Programmiersprache R.
Unsere bevorzugten Programmbibliotheken sind tidyverse, igraph, (optional tidygraph, ggraph und ggnet).
Du hilfst Studierenden bei ihren Projekten und sprichst in einer einfachen, direkten Sprache.
Du kannst Code in Markdown erstellen und beim Verst√§ndnis des Codes weiterhelfen.
Bitte annotiere Deinen Code entsprechend und trenne Codechunks von Interpretationen.
Bitte gib auch an, welchen Code oder welches Programmpaket Du gerade zur L√∂sung verwendest.
Bitte gib genau an, in welchem Format und wie Fragen gestellt werden sollen.
Schlage dann eine L√∂sung auf eine Frage mit einem Beispiel vor.
Frage nach, ob das Problem gel√∂st wurde.
Sag auch gerne Du zu mir.


# Grunds√§tzliches Vorgehen Netzwerkanalyse

##Ablauf Netzwerkanalyse
**1. Forschungsfrage & Pretest festlegen**
-->vorl√§ufige Forschungsfrage aufstellen
-->√§hnliche Untersuchen recherchieren: Wie sind die vorgegangen? Parallelen zu unserem Projekt?
-->Sample festlegen
-->Datenzugang sicherstellen & dokumentieren
-->Erhebung: festlegen, was genau erhoben werden soll
-->Codebuch aufstellen
  -->Variablen (Node-Attribute)
  -->Beziehungen & ggf. deren Gewichtungen (Edge-Attribute)
-->Pretest mit kleinem Sample durchf√ºhren

**2. Antwort Pretest**
-->Forschungsfrage ggf.nochmal eingrenzen / anpassen 

**3. √Ñhnliche Studien im Detail durchgehen**
-->√§hnliche Untersuchen recherchieren: Wie sind die vorgegangen? Parallelen zu unserem Projekt?
-->Schneeball-Methode: in den LVs nach weiteren verweisenden Quellen nachgucken

**4. Datenerhebung**
-->Erhebung Eigenschaften Akteur*innen in Nodelist 
-->Erhebung Bez. der Akteur*innen zueinander in Edgelist
-->bei Erhebung der Daten immer Crosscheck Dateneintrag: mind. 2 best√§tigte Aussagen von mind. 2 seri√∂sen & zuverl√§ssigen Quellen
-->Edge- & Nodelist pr√ºfen (Datenbereinigung) & sichern 
-->Dateien auf Guthub hochladen

**5. Analyse in R(Studio)**
-->Datensatz, Edge- & Nodelist einlesen
-->Datensatz auf Forschungsfrage hin analysieren 
-->Visualisierung nach Forschungsfrage

**6. Ergebnisse in Forschungsbericht festhalten**
-->Abstract
-->Zugang 
-->Methodik
-->Analyse
-->Fazit, Diskussion, Ausblick & Co.
-->Quellen / LV
-->etc.








##Grundregeln f√ºr die Analyse und Visualisierung

1)  *Was* wollen Sie herausfinden?
2)  *Wie* k√∂nnen Sie das Ziel erreichen?

-   Geht es um Knoten oder Kanten?
-   Muss das Netzwerk daf√ºr weiter unterteilt werden?
-   Hilft ein Vergleich?
-   Helfen Netzwerk- oder Zentralit√§tsma√üe?

3)  Achten Sie auf die aufeinanderaufbauenden Schritte!

-   Analysen oder Teilnetzwerke beziehen sich oft auf ver√§nderte
    Variablen.
-   Achten Sie auf die richtigen Bez√ºge innerhalb eines Chunks.

3a) Dauerhafte Visualisierung vs. plot - Definierte Attribute E(g) oder
V(g) bleiben erhalten - Im plot() Befehl angelegte Parameter gelten nur
f√ºr diese Visualisierung und ignorieren die dauerhaft angelegten
Attribute, falls diese abweichen sollten. - Regel: nur die Attribute
dauerhaft setzen, die f√ºr alle gelten sollen.

3b) Auswahl des Layouts: Achten Sie auf ein geeignetes Layout und eine
Legende.

4)  Verwenden Sie niemals die gleichen Variablen in einer Analyse.

-   Pro Chunk einen logischen Analyseschritt gehen, der zusammengeh√∂rt.
-   Pro Chunk maximal eine Visualisierung bzw. einen Vergleich.
-   Beginn immer mit Programmbibliothek und Erstellen des
    igraph-Objekts.
-   Jeden Chunk beschriften und kommentieren.

5)  Wie l√§sst sich das Ergebnis interpretieren?

6)  Wo gibt es √§hnliche Analysen, an denen ich mich orientieren kann?
    Nutzen Sie die vorhanden Skripte! In der Regel m√ºssen Sie nur die
    Variablen im Chunk austauschen.
    <https://github.com/kateto/R-Network-Visualization-Workshop>
    <https://github.com/hdm-crpr/226305/tree/master/data>

7)  L√∂schen Sie regelm√§ssig die eingelesenen Variablen, d.h. bevor Sie
    ein Netzwerk neu analysieren. Environment -\> Data -\> Besen.

8)  Wenn Sie neue Pakete installieren, starten Sie R neu und erstellen
    Sie das Netzwerk neu.


# Teil 1: Wissensfragen

#Bsp. FAQs

1.  Wie lassen sich nicht nur der Top-Degree, sondern auch auch die
    weiteren Top-Werte anzeigen oder sortieren lassen?
2.  Lassen sich Teilnetzwerke auch anders erstellen? (anstatt mit
    delete.vertices): \
    -\> ja, das steht im Forschungsbericht oder der Anleitung, z.B.
    subgraph.edges
3.  gibt es eine M√∂glichkeit in igraph eine Legende anzulegen bei der
    Visualisierung?\
    -->im Plot-Befehl main f√ºr die Haupt√ºberschrift & sub f√ºr die Unter√ºberschrift
    -\> ja, z.B. direkt im SNA Helper oder automatisch im Paket ggraph()
    \
    <https://ggraph.data-imaginist.com/index.html> oder tidygraph:
    <https://www.mr.schochastics.net/material/tidynetAnaR/index.html>
4.  kann das so funktionieren? Wir m√∂chten ein Netzwerk mit zwei
    relations visualisieren\
    Sie k√∂nnen jede relations als Teilnetzwerk darstellen bzw.
    alternativ diese Kanten auch einf√§rben.

#Wichtige Tipps

--> immer in Chunk am besten zuerst library laden, das beugt unn√∂tige Fehlermeldungen vor
--> immer zuerst den Setup-Chunk runnen

#Begriffserkl√§rungen und -definitionen


## Definition Netzwerkforschung 

--> Eine (soziale) Netzwerkanalyse ist eine empirisch orientierte Methode, die die (sozialen) Beziehungen zwischen verschiedenen Akteur*innen betrachtet, indem Analytiker*innen beobachten, wie regelm√§√üig Akteur*innen eines Netzwerkes miteinander interagieren, wodurch letztlich soziale Ph√§nomene anhand von erkennbaren Mustern erkl√§rt werden k√∂nnen (vgl. Fuhse, 2018, S.12; S. 14-15). 
--> Empirisch orientierte Netzwerkforschung 
--> Empirische Untersuchung von sozialen Strukturen 
--> Fokus liegt auf Beziehungsgeflechten zwischen Akteur*innen 
--> Effekte von sozialen Netzwerken 
--> Arbeitsstellen werden √ºber bestimmte soziale Beziehungen (Kontakte aka. VitaminB) vergeben ÔÉ† ‚Äûweak ties‚Äú 
--> Beruflicher Aufstieg beg√ºnstigt durch Position in sozialen Netzwerk im Unternehmen 
--> Wechsel von Regimes anhand sozialer Beziehungsnetze ÔÉ† z.B.  von Republik zu anderer Staatsform 
--> Erfolg sozialer Bewegungen abh√§ngig von sozialen Netzwerken ÔÉ† zu Rekrutierungszwecken 
--> Netzwerke sind auf unterschiedlichen Ebenen entscheidend 
--> Zw. Individuen & Organisationen 
--> Also wichtige Rolle von Netzwerken in sozialen Bereichen 


## Definition Netzwerk 

--> Soziales Netzwerk = Muster an Sozialbeziehungen zw. einer Menge von Akteur*innen 
--> bildet Beziehungen & (komplexe) Zusammenh√§nge ab 
  --> komplex: ineinandergreifend, nicht allein f√ºr sich    auftretend, nicht aufl√∂sbar 
  --> kompliziert: schwierig 
--> Sozialbeziehungen = beobachtbare Regelm√§√üigkeiten in der Interaktion zwischen Akteur*innen 
--> Es bestehen oft auch Erwartungen √ºber das Verhalten der entsprechenden Akteur*innen zueinander 
--> Beziehungen leben von Kommunikation (analog und / oder digital)
--> Formal-mathematische Betrachtung 
--> Netzwerk besteht aus Knoten = Akteur*innen + Verbindungen/Kanten = Sozialbeziehungen zwischen Akteur*innen 
--> Akteur*innen = Individuen/Orgas/Staaten
--> Soziale Beziehungen k√∂nnen symmetrisch oder asymmetrisch sein 


## Grundbegriffe der SNA 

##Zusammenhang Edge- und Nodelist
**Nodelist:** 
-->Daten √ºber einzelne Knoten
-->in Netzwerkanalyse erhobene Angaben zu Eigenschaften der Knoten / Akteur*innen sind darin festgehalten
-->Minimalanforderung: id,name, wobei id dann den codierte Wert f√ºr die Edgelist darstellt
-->beliebig viele Eigenschaften f√ºr Knoten m√∂glich (nat√ºrlich abh√§ngig von der Gr√∂√üe des Netzwerkes)
-->exakt ein Wert pro Spalte 
-->Bsp. Node-Attribute: (Vor-)Name, Geschlecht, Alter, Vertiefungsrichtung (Studi-Netzwerk CR/PR)
-->Node-Attribut type in einem two-mode-Netzwerk: Unterscheidung von Knotenaren, z.B. Person oder Organisation (ist dann auch wieder codiert)
**Node-IDs** 
-->m√ºssen identisch zur Edgelist sein
-->d√ºrfen in Nodelist aber nur genau einmal vorkommen
**Edgelist**
-->Daten √ºber Beziehungen zwischen den Knoten
-->in Netzwerkanalyse erhobene Angabe zu Beziehungen der Knoten / Akteur*innen sind darin festgehlaten
-->also Kanten
-->Minimalanforderung: from,to
-->in jeder Spalte darf immer nur exakt ein Wert aufgef√ºhrt sein; Wert kann aus Text oder Zahlen bestehen
-->Bsp. Edge-Attribute: relation (Beziehung zueinander), Gewicht als St√§rke der jeweiligen Beziehungen, im Studi-Netzwerk auch z.B. Ratsuche & Zusammenarbeit
-->aus solchen Edge-Attributen wie Ratsuche & Zusammenarbeit lassen sich dann z.B. auch Teilnetzwerke generieren 
**Edge- und Nodelist: Formalia**
-->werden als .csv-Dateien abgespeichert aka. "comma separated values
**Minimal-Anforderung f√ºr eine soziale Netzwerkanalyse**
-->vorhandene Edgelist (ohne Gewicht der Beziehungen)
-->Netzwerk wird dann aussagekr√§ftiger, wenn zus√§tzliche Daten zur Relation der Knoten zueinander erg√§nzt werden, z.B. das Gewicht der Beziehung
-->auch dann aussagekr√§ftiger, wenn man Daten zu den Eigenschaten der Knoten in einer Nodelist hat 
**Merksatz**
-->jede Beziehung, dargestellt durch die Kanten, ist eine Zeile in der Edgelist 
-->jeder Knoten ist aber nur genau einmal in der Nodelist zu finden
-->Edge- und Nodelist werden in R in ein igraph-Objekt √ºbertragen
-->dieses igraph-Objekt f√ºhrt die Werte dann als Edge- und Vertex-/Node-Attribute weiter 


### Kanten 
--> tie/edge/relation
--> Verbindungen von Knoten, die miteiander in Beziehung stehen 
--> k√∂nnen 
  --> Trannsfermuster (Geld)
  --> Beziehungsmuster 
  --> Abh√§ngigkeiten 
darstellen. 

### Knoten 
-->	nodes/vertices (vertex) 
--> K√∂nnen auch f√ºr sich alleine stehen 
--> stellen Eigenschaften Netzwerkakteur*innen dar 
--> Person/Organisation/sonstige*r Akteur*in 
--> Ist in der Regel mit anderen Akteur*innen verbunden 
--> eher in Beziehung zueinander 

### Weight/Gewicht: 
--> Intensit√§t der Beziehung zueinander 
--> Meist skaliert/codiert 
--> In Visualisierung: Kanten je nach St√§rke unterschiedlich dick

### Degree/Richtung: 
-->**Zentralit√§tsma√ü**
-->Anzahl der Kanten / Beziehungen eines Knoten in einem Netzwerk
-->Anzahl direkter Verbindungen zu anderen Akteur*innen
-->Indegree: Beziehung von Alteri zu Ego hin -->Verbindungen zum Knoten
-->Outdegrees: Beziehung von Ego zu Alteri -->Au√üenverbindungen Knoten
--> Richtung --> direction-->wo also die Pfeile zw. den Knoten hinzeigen 
--> egal, ob gerichtetes oder ungerichtetes Netzwerk 
--> Pfeile der Kanten haben Richtung, in die sie von den Knoten aus zeigen 
--> Einseitig oder beidseitig 
--> Gibt an, ob Beziehung zwischen Akteur*innen stattfindet &, ob gegenseitig (Pfeile zeigen von beiden jeweils zum anderen Akteur*in) oder nicht (Pfeile von Akteur*in nur einseitig) 
--> Beidseitig: Beziehung ist reziprok 
-->igraph: 
  -->absolute Zahlen: **degree(Netzwerk)**
  -->Prozentzahlen: **degree(Netzwerk, normalized=TRUE)**
-->nur bei gerichteten Netzwerken
  -->Indegree: **degree(Netzwerk, mode="in")**
  -->Indegree prozentual: **degree(Netzwerk, mode="in", normalized=TRUE)**
  -->Outdegree: **degree(Netzwerk, mode="out")**
  -->Outdegree prozentual: **degree(Netzwerk, mode="out", normalized=TRUE)**
  
**Interpretation**
-->viele Outdegrees: hohe Kommunikatiosnaktivit√§t, Ma√ü f√ºr Aktivit√§t / Verbundenheit zu Alteri
-->viele Indegrees: gute Erreichbarkeit, Ma√ü f√ºr Popularit√§t

###Preferential Attachment
-->kein Netzwerk- oder Zentralit√§tsma√ü an sich 
-->l√§sst sich aus Degree-Werten ableiten 
  -->Power-Law-Verteilung anhand der Degree-Zentralit√§ten
  -->hat Akteur*in viele Indegrees: alteri pflegen Bez. zu Akteur*in 
  -->hat Akteur*in viele Outdegrees: ego ist nach au√üen gut vernetzt 
-->beschreibt die Orientierung an Akteur*innen mit Zuspruch 
  -->bspw. Influencer*innen mit vielen Follower*innen
-->wird auch Matth√§us-Effekt genannt, nach Vers Matth√§us-Evangelium "Der da hat, dem wird noch gegeben"


##Typen von Netzwerken

### One-Mode-Netzwerk
--> nur eine Dimension / Kategorie von Knoten wird betrachtet: z.B. Ratsuche im Studi-Netzwerk 
--> One-Mode-Netzwerk: eine Kategorie von Knoten, z.B. nur Twitter-Accounts 

### Two-Mode-Netzwerk/Bipartite
-->	n > 10 bis hin zu Millionen von Akteur*innen 
--> mehrere Kategorien von Knoten 
  -->Personen
  -->Orgas 
  -->	Wer ist Mitglied in Orga? 
--> 2 Kategorien von Knoten
--> Vs. One-Mode-Netzwerk: eine Kategorie von Knoten, z.B. nur Twitter-Accounts 

##Netzwerkma√üe

###Dichte
-->**Netzwerkma√ü**
-->Dichte eines Netzwerks beschreibt den Anteil der realisierten von den insgesamt m√∂glichen Beziehungen
-->Anzahl der realisierten Beziehungen in (Netzwerk) geteilt durch (/) Anzahl aller m√∂glichen Beziehungen (Netzwerk)
-->Wert ist normalisiert von 0 bis 1
--> 1 = komplett dichtes Netzwerk, also starke Verbindung
--> 0 = keine Verbindung
-->alles, was dazwischen ist: je n√§her an 1, desto dichter, je n√§her an null, desto zerfallener ist das Netzwerk
-->gibt also an, wie eng die Beziehungen zw. den Akteur*innen im Netzwerk sind 
-->Beziehungen m√ºssen hierf√ºr nicht unbedingt reziprok sein 
-->igraph: **edge_density(Netzwerk)**

###Durchmesser
-->**Netzwerkma√ü**
-->z√§hlt die max. Distanz zwischen Knoten in einem Netzwerk in Schritten
-->max. Pfad in eine Richtung zw. Knoten
-->liefert damit Aussagen √ºber die Gr√∂√üe des Netzwerkes 
-->igraph:
  -->Aufruf Durchmesser: **diameter(Netzwerk)**
  -->Berechnung Durchmesser: **get_diameter(Netzwerk)** --> zeigt die Knoten mit der l√§ngsten Pfaddistanz 
  -->am weitesten entfernt: **farthest_vertices(Netzwerk)**
  --> welche Knoten am weitesten voneinander entfernt: **get_farthest(Netzwerk)**
  
###Umfang
-->maximal k√ºrzeste Pfaddistaz eines Knotens zu allen anderen Knoten (ChatGPT, 2023, Promt: Was ist in igraph der Unterschied zwischen Umfang und Durchmesser eines Netzwerkes und mit welchen Befehlen berechnet man sie jeweils?)
-->igraph (Angabe Sandhu Apollo-Lsg. 226305 Apollo Solution sws2076: # Umfang
**diameter(Netzwerk)** #Wert Pfaddistanz vom Knoten zu allen anderen Knoten
  
###Pfaddistanz
-->**Netzwerkma√ü**
-->maximaler Pfad in eine Richtung zw. Knoten
-->berechnet die Anzahl der (gerichteten) Verbindungen, √ºber die ein*e Akteur*in eine*n zweite*n Akteur*in im Durchschnitt erreichen kann 
-->igraph: **mean_distance(Netzwerk)**
-->igraph: **get_farthest(Netzwerk)** / **farthest_vertices(Netzwerk)** --> Knoten, die am weitesten voneinander entfernt sind 

###Reziprozit√§t
-->**Netzwerkma√ü**
-->berechnet die Anzahl der reziproken (wechselseitigen) Beziehungen im Verh√§ltnis zu allen Beziehungen im Netzwerk
-->normalisiert den Wert (also Reziprozit√§t als Prozentangabe)
-->ist nur bei gerichteten Netzwerken m√∂glich 
-->igraph: **reciprocity (Netzwerk)**

###Components (Teilnetzwerke)
-->**Netzwerkma√ü**
-->berechnet die Anzahl der nicht-verbundenen Teilnetzwerke eines Netzwerkes
-->also die verschiedenen Komponenten des Netzwerkes
-->igraph: **components(Netzwerk)**

###Cluster (Teilnetzwerke)
-->**Netzwerkma√ü**
-->berechnet die Anzahl der verbundenen Teilnetzwerke innerhalb eines Netzwerkes 
-->igraph: **cluster.distribution (Netzwerk)**


##Zentralit√§tsma√üe

### Degree/Richtung: 
-->**Zentralit√§tsma√ü**
-->Anzahl der Kanten / Beziehungen eines Knoten in einem Netzwerk
-->Anzahl direkter Verbindungen zu anderen Akteur*innen
-->Indegree: Beziehung von Alteri zu Ego hin -->Verbindungen zum Knoten
-->Outdegrees: Beziehung von Ego zu Alteri -->Au√üenverbindungen Knoten
--> Richtung --> direction 
--> egal, ob gerichtetes oder ungerichtetes Netzwerk 
--> Pfeile der Kanten haben Richtung, in die sie von den Knoten aus zeigen 
--> Einseitig oder beidseitig 
--> Gibt an, ob Beziehung zwischen Akteur*innen stattfindet &, ob gegenseitig (Pfeile zeigen von beiden jeweils zum anderen Akteur*in) oder nicht (Pfeile von Akteur*in nur einseitig) 
--> Beidseitig: Beziehung ist reziprok 
-->igraph: 
  -->absolute Zahlen: **degree(Netzwerk)**
  -->Prozentzahlen: **degree(Netzwerk, normalized=TRUE)**
-->nur bei gerichteten Netzwerken
  -->Indegree: **degree(Netzwerk, mode="in")**
  -->Indegree prozentual: **degree(Netzwerk, mode="in", normalized=TRUE)**
  -->Outdegree: **degree(Netzwerk, mode="out")**
  -->Outdegree prozentual: **degree(Netzwerk, mode="out", normalized=TRUE)**
  
**Interpretation**
-->viele Outdegrees: hohe Kommunikatiosnaktivit√§t, Ma√ü f√ºr Aktivit√§t / Verbundenheit zu Alteri
-->viele Indegrees: gute Erreichbarkeit, Ma√ü f√ºr Popularit√§t

###Preferential Attachment
-->kein Netzwerk- oder Zentralit√§tsma√ü an sich 
-->l√§sst sich aus Degree-Werten ableiten 
-->beschreibt die Orientierung an Akteur*innen mit Zuspruch 
  -->bspw. Influencer*innen mit vielen Follower*innen
-->wird auch Matth√§us-Effekt genannt, nach Vers Matth√§us-Evangelium "Der da hat, dem wird noch gegeben"


###Closeness
-->**Zentralit√§tsma√ü**
-->zentrale Frage: Wie schnell kann dieser Knoten alle anderen Knoten im Netzwerk erreichen?
  -->Hub, bzw. Verteilerknoten f√ºr Informationen
-->Out-Closness: Anzahl Verbindungen, die ein*e Akteur*in nutzen muss, um alle Alteri zu erreichen 
-->In-Closeness: Anzahl Verbindungen, um von allen Alteri erreicht zu werden
-->igraph: **closeness(Netzwerk)**
-->igraph/ prozentual: **closeness(Netzwerk, normalized=T)**
--> funktioniert vom Prinzip her wie degree-Befehl
**Interpretation**
-->hohe Out-Closeness: geringe Distanz zu allen Alteri, also Unanbh√§gigkeit / Effizienz 
-->hohe In-Closeness: gute Erreichbarkeit

###Betweenness
-->**Zentralit√§tsma√ü**
-->Anzahl k√ºrzester Verbindungen zwischen allen Akteur*innen, die durch Ego gehen
-->zentrale Frage: Wie wahrscheinlich ist es, dass dieser Knoten die Verbindung zu anderen Knoten im Netzwerk herstellen kann? 
  -->Br√ºcke, bzw. Verbindung
-->igraph: **betweenness(Netzwerk)**
(-->igraph /prozentual: **betweenness(Netzwerk, normalized=T)**)
**Interpretation**
-->hohe Zentralit√§t bedeutet gute Kontrolle √ºber die Kommunikation unter den Alteri



##Teilnetzwerke

###Components (Teilnetzwerke)
-->**Netzwerkma√ü**
-->berechnet die Anzahl der nicht-verbundenen Teilnetzwerke eines Netzwerkes
-->also die verschiedenen Komponenten des Netzwerkes
-->igraph: **components(Netzwerk)**

###Cluster (Teilnetzwerke)
-->**Netzwerkma√ü**
-->berechnet die Anzahl der verbundenen Teilnetzwerke innerhalb eines Netzwerkes 
-->igraph: **cluster.distribution (Netzwerk)**


###Dyade (Teilnetzwerke)
-->Beziehung zwischen zwei Akteur*innen / Knoten 
-->Dyaden sind wichtige Bausteine f√ºr Netzwerke. Bei gerichteten Netzwerken
l√§sst sich hier das Ma√ü der Reziprozit√§t berechnen.
--> Reziprozit√§t beschreibt wechselseitige Beziehungen
**Dyaden-Zensus**
-->igraph:**dyad_census**

###Triade (Teilnetzwerke)
-->Beziehung zw. 3 Knoten /Akteur*innen
-->**Triadenzensus** Der Triadenzensus ist ein etabliertes Instrument, um
die Zusammensetzung von Netzwerken zu analysieren und zu vergleichen.
-->16 verschiedene Triaden-Typen (siehe Fuhse Zusammenfassung S. 13-14 in meinem Word-Dokument)
-->kann man im Chunk aber auch ganz schnell auf einen Blick aufrufen √ºber **?triad_census**

###Ego-Netzwerk 

####Ego-Netzwerk erster Ordnung 
-->Erhebung von soziodemographischen Merkmalen, z.B. Geschlecht, Bildungsstatus, Berufsstatus (in Nodelist)
-->in Edgelist Aussagen √ºber Beziehungsintensit√§t zu mit Ego verbundenen alteri
-->wird generiert durch einen **Namensgenerator**
  -->Fuhse 2016, S.118
  -->Namensgenerator als Instrument zur Erhebung von wichtigen Bezugspersonen 
  -->wird in standardisierten Interviews durchgef√ºhrt
  -->meist mehrere Fragen: Welche Personen sind f√ºr die Befragten wichtig?, Wer unterst√ºtzt die Befragten?, Mit wem machen die Personen gemeinsame Aktivit√§ten?
-->**Namens-Interpretator**
  -->Fuhse 2016, S.121
  -->mit dessen Hilfe Einblick in Anzahl & Art der Beziehungen, Eigenschaften & Verhaltensmuster & Bez. zw. den von Ego genannten Bezugspersonen
  -->also sowohl soziodemograph. Daten als auch Beziehungen zw. den Bezugspersonen von ego
-->**zentrale Dimensionen Namens-Interpretatoren**
  -->Anzahl Bezugspersonen von ego
  -->Art der Beziehungen
  -->Eigenschaften der Bezugspersonen
  -->Bez. zw. den Bezugspersonen von ego
-->Manchmal ist es hilfreich, bestimmte Knoten aus dem Netzwerk zu
extrahieren, um diese genauer zu untersuchen. 
-->Damit "zoomt" man auf
einen Knoten im Netzwerk. 
-->**Jedes Netzwerk besteht aus Egos (einzelne Knoten) und deren Alteri (andere Knoten, die mit dem zu analysierenden Ego verbunden sind)**. 
-->Diese Ego-Netzwerke lassen sich auch einzeln
analyisieren. 
-->Wir verwenden daf√ºr die Befehle ego_size() und
make_ego_graph().
-->wenn man egos zsmaddiert, erh√§lt man ego-Netzwerk 1.+2. Grades

####Ego-Netzwerke zweiter & dritter Ordnung
-->Ego-Netzwerke lassen sich
leicht um die zweite oder dritte Ordnung erweitern. Dies erm√∂glicht eine
genauere Analyse 
--> erste Ordnung: nur Beziehung Ego zu Alteri 
--> zweite Ordnung: Beziehung Alteri zu weiteren Alteri miteinbezogen (quasi erweitert um deren Beziehungen zu deren Kontakten)
--> dritte Ordnung: Beziehung von Ego zu Alteri, Alteri zu deren Kontakten, Kontakte Alteri zu wiederrum deren Kontakten

###Erkl√§rungsmechanismen 

####weak ties:
ÔÅ∂	Starke Beziehungen = enge Freundschaft, Liebe, direkte Verwandtschaft
ÔÉò	Verbindungen zu Personen, die sich auch oft untereinander kennen 
ÔÉò	Wir erfahren von diesen Personen wenig wichtige neue Informationen
ÔÉò	Da wir uns meistens im gleichen Netzwerk wie sie bewegen
ÔÉò	Informationen sind also redundant 
ÔÅ∂	Schwache Beziehungen = eher oberfl√§chliche Beziehungen
ÔÉò	Bekannte, (ehemalige) Kommiliton*innen, Arbeitskolleg*innen  
ÔÉò	Nicht-redundante Informationen k√∂nnen an uns weitergegeben werden, da sie sich in anderen Netzwerk-Kreisen bewegen als wir 
ÔÉò	Z.B. Tipps zu freien Arbeitsstellen
ÔÅ∂	Informationsfluss f√ºr uns wichtiger, neue Dinge/Informationen meist √ºber schwache Beziehungen 
ÔÉò	Oberfl√§chliche Bekanntschaften 
ÔÇß	Arbeitskolleg*innen 
ÔÇß	Fr√ºhere Kommiliton*innen
ÔÉò	Da eher neue wichtige Informationen, da sich diese Menschen in anderen Netzwerk-Kreisen bewegen als wir 

-->schwache Verbindungen 
-->sind oft n√ºtzlicher, um neue Informationen zu erhalten
-->da sich austauschende Akteur*innen nicht in den gleichen Netzwerkkreisen verkehren & darum anderen Informationszugang haben 
-->praktisch f√ºr Wohnungssuche / Job-Stelle bekommen 
**bekannte Netzwerkstudien / -analysen**
-->Mark Granovetter: "Getting a job" / "Strenght of weak ties" 1970er
  -->Knoten, die schwache Verbindungen zu anderen Knoten aus anderen Netzwerken haben & somit Informationsaustausch zwischen diesen Netzwerken f√∂rdern, sind Br√ºcken / Broker zwischen den Netzwerken 

####strukturelle L√∂cher
ÔÅ∂	Ansonsten unverbundene Netzwerke bauen √ºber eine Br√ºcke zwischen den Netzwerken (einzelne*r Akteur*in) eine Verbindung/Beziehung zueinander auf 
ÔÉò	Z.B. eine Person in einem Netzwerk hat schwache Beziehung aka. losen Kontakt zu Person aus anderem Netzwerk ÔÉ† ist also die Br√ºcke im strukturellen Loch 
ÔÇß	so z.B. Infos √ºber neue Arbeitsstelle m√∂glich
-->Broker schlie√üen also strukturelle L√∂cher 


####small world:
-->**Small World Theory**
  -->wir k√∂nnen √ºber gro√üe Distanz Netzwerke herstellen 
  -->wir sind alle eng miteinander verbunden, k√∂nnen so gro√üe Distanzen √ºberbr√ºcken
**bekannte Netzwerkstudien / -analysen**
-->Stanley Milgram: "Six Degrees of Separation" 1960er
  -->Brief von Nebraska nach Boston
  -->Brief einer Person geben, die wahrscheinlich jemanden kennt, der*die in Boston lebt
  -->Ziel: Brief sollte es von Nebraska irgendwie nach Boston schaffen
  -->im Schnit 6 Zwischenschritte ben√∂tigt 
  -->durch Facebook hat sich die Anzahl der Zwischenschritte auf 2,5 verringert 
  -->allg. ca. 3-4 Schritte, die Akteur*innen in Vernetzung voneinander trennen


####Homophilie
-->Die Homophilie untersucht die Struktur√§hnlichkeit von Knoten in
Netzwerken.
-->**Homophilie** betont die √Ñhnlichkeit von
Knoten.
--> gleich und gleich gesellt sich gern
--> Werte-Homophilie: √Ñhnlichkeit in Werten und Weltanschauungen
--> √Ñhnlichkeit in Eigenschaften (Geschlecht, Ethnie, Alter, etc.)
--> Status-Homophilie: z.B gleicher Bildungssgrad, insgesamt gleicher sozialer Status 
-->igraph verwendet zur Berechnung von Homophilie den Wert **Assortivit√§t**: Dieser Wert gilt als positiv, wenn sich √§hnliche Knoten (aufgrund deren Eigenschaften) miteinander verbinden. Ansonsten wird der Wert negativ berechnet.
--> wenn Wert also negativ ist, dann keine Homophilie


####Transitivit√§t
-->**Transitivit√§t** beschreibt die M√∂glichkeit, dass zwischen Knoten
eine Weitergabe stattfindet
-->Transitivit√§t beschreibt den Hang der Knoten des Netzwerks, sich zu gruppieren. 
-->Je h√∂her die Transitivit√§t innerhalb des Netzwerks, desto mehr Gruppen sind vorhanden.
--> Streben nach ausgeglichenen Beziehungen 
--> wenn A und B jeweils mit C befreundet sind, ist die Wkeit hoch, dass A und B sich auch miteinander anfreunden


####Reziprozit√§t
-->**Netzwerkma√ü**
-->F√ºr die Berechnung der Reziprozit√§t vergleichen wir die Teilnetzwerke
-->**Reziprozit√§t** ist die gegenseitige Anerkennung in Netzwerken, d.h. dass
Knoten (in gerichteten Netzwerken) gegenseitig gegenseitig verbunden
sind. 
--> wechselseitige Beziehungen 
-->berechnet die Anzahl der reziproken (wechselseitigen) Beziehungen im Verh√§ltnis zu allen Beziehungen im Netzwerk
-->normalisiert den Wert (also Reziprozit√§t als Prozentangabe)
-->ist nur bei gerichteten Netzwerken m√∂glich 
-->igraph: **reciprocity (Netzwerk)**




### SNA Aufgaben Netzwerke Edge- & Nodelist auf Github hinterlegen & dann in RStudio importieren 
--> Aus Edge- & Nodelist igraph-Objekt erstellen 
--> Leichter als Excel: Google Table 
--> Namen der Kategorien m√ºssen in Edge- & Nodelist √ºbereinstimmen
--> Wenn ich also bei beidem id oder name habe, muss das in beiden Listen f√ºr die gleiche Kategorie den gleichen Namen tragen 
--> Nodes d√ºrfen in Nodelist genau einmal vorkommen 
--> In Edgelist mehrfach 
--> Datei immer als CSV-Datei speichern ÔÉ† comma separated values --> Listen auf Github hochladen 
--> Verzeichnis erstellen ÔÉ† create a new file & Namen angeben 
--> Immer readm.md ‚Äì Datei ÔÉ† immer mit .md-Endung f√ºr Markdown-Dokument 
--> Dann auf ‚Äûcommit new file‚Äú gehen 
--> ‚Äûupload files‚Äú
--> Dateien in das erstellte Verzeichnis hochladen 
--> In der Beschreibung angeben, was man gemacht hat 
--> √Ñnderungen speichern mit ‚Äûcommit changes‚Äú 
--> Listen m√ºssen korrekt in Tabellen-Ansicht angezeigt werden 
--> Beim Einlesen den Github-Link angeben 
--> Github-Link kopieren in RStudio ÔÉ† auf Raw in Anzeige gehen & dann Link rauskopieren, um den richtigen Link einzulesen 
--> Anzeige in Console: v/n: vertex/nodes, e: egdes 
--> Plot √úberschrift hinzuf√ºgen
--> plot(Name Netzwerk, main=‚Äù√úberschrift‚Äú)
--> Plot Unter√ºberschrift hinzuf√ºgen plot(Name Netzwerk, main=‚Äù√úberschrift‚Äú, sub=‚ÄúUnter√ºberschrift‚Äú)
--> Grafik /Plot exportieren ÔÉ† Export als PDF, Landscape-Mode dann speichern 

###Komplexe Netzwerke
-->komplex: ineinandergreifend, nicht allein f√ºr sich auftretend, nicht aufl√∂sbar
-->kompliziert: schwierig
-->In komplexen Netzwerken h√§ngen verschiedene Gruppen/Weltgeschehnnisse/ Ereignisse zusammen und sind miteinander verbunden

###Kipp-Punkte 
--> Punkte in einem Netzwerk, die f√ºr das Netzwerk -Konstrukt entscheidend sein k√∂nnen
-->z.B. Kipp-Punkte im Klimasystem: Schmelzen von Eisschilden ausgel√∂st durch Einflussgr√∂√üe der Erd-Erw√§rmung
-->die Momente, in denen eine vorher geradlinig verlaufende Entwicklung nicht mehr geradlinig verl√§uft, also ihre Richtung wechselt oder stark beschleunigt wird (Quelle: Wikipedia)

###Kollektives Verhalten
-->Verhalten eines Kollektivs / einer Gruppe / eines Netzwerkes kann ma√ügeblich Einfl√ºsse auf Handlungsverl√§ufe nehmen 

###Koordination
-->Netzwerk bedarf einer ausgefeilten Koordination, um weitere Handlungsverl√§fe zu beeinflussen


##Klassiker in der Netzwerkforschung

###Deep South (Davis 1941)
-->eine der ersten Netzwerkstudien: Frauen bei einer Tee-Party in Georgia --> Wie setzt sich ein Frauennetzwerk zusammen?
-->nach dem Treffen am 16. September sind die Frauen, die davor gekommen sind, nicht mehr gekommen-->es muss also eine Art Zerw√ºrfnis im Netzwerk gegeben haben 

###Six Degrees of Separation (s. Erkl√§rungsmechanismen small world)

###Familienstrukturen in Florenz (Studie aus den 1990ern)
-->im 15.Jhrd haben in Florenz einzelne einflussreiche Familien die Stadt quasi beherrscht 
-->darunter auch die Medici
-->Untersuchungsgegenstand Forschung: Wie werden die Kinder der einzelnen Familien mit welchen Kindern aus anderen Familien verheiratet, um die Machtpositionen der Medici strukturell zu erhalten?
-->Ergebnis: strategische Hochzeiten, um mehr Macht zu gewinnen, auch Kinder von verfeindeten Familien werden verheiratet

###Diffusionsntzwerke
-->Simulation: Verbreitung von Ger√ºchten 
-->die Verbreitung dieser gezielt gestreuten Falschinformation/Desinformation/Falschnachrichten war Untersuchungsgegenstand
-->Verbreitung von FakeNews in den Medien
-->Falschnachrichten verbreiten sich schneller als wahre Nachrichten

###Social Media Echokammern 
-->jede Transaktion, die wir digital t√§tigen, ist quasi eine Kante in einem Social-Media-Echokammer-Netzwerk
-->Cluster von progressiven vs. konservativen Echokammern 
-->auch Untersuchungsgegenstand: Welchhe*r User*in liest welche Nachricht in einem Social-Media-Echokammer-Netzwerk und wie beeinflusst das diese Person?


##Netzwerkmechanismen

###Definition Netzwerkmechanismen

ÔÉò	Netzwerk-Mechanismus = kleinteiliger, kausaler Zsmhang zw. 
ÔÇß	Struktur der Bez. zw. den Akteur*innen 
ÔÇß	& der Zusammensetzung sozialer Netzwerke & anderer soz. Tatsachen
  ‚Ä¢	ÔÉ† Aus welchen Komponenten besteht das Netzwerk? 
ÔÉò	Zusammensetzung ist theoretisch plausibel & empirisch dokumentiert 
ÔÉò	Je nach Rolle der Netzwerke 
ÔÇß	Netzwerkbildung 
  ‚Ä¢	Netzwerke als abh√§ngige Variable 
  ‚Ä¢	H√§ngt z.B. von soz. Tatsache ab
ÔÇß	Netzwerkeffekte 
  ‚Ä¢	Netzwerke als unabh√§ngige Variable 
  ‚Ä¢	Netzwerk hat also Effekte auf etwas Anderes / auf Akteur*innen 
ÔÇß	Netzwerkstrukturierung
  ‚Ä¢	Netzwerke als unabh√§ngige & auch als abh√§ngige Variable 
  ‚Ä¢	Abh√§ngig von einer soz. Tatsache
  ‚Ä¢	Wirkt sich auf weitere soz. Tatsachen aus 


###Beispiele Netzwerkmechanismen

####Netzwerkbildung

#####Aktivit√§tsfokus /-foki
-->**Wirkung**: bietet Gelegenheit zum Kontakt & erh√∂ht somit die Wkeit, dass sich eine Beziehung zw. Akteur*innen bildet
-->**Bsp**.: Uni-Vorlesung (wenn Vorlesung in Pr√§senz), Dorf-Netzwerke, Vereine (z.B. Sportvereine), Gemeinden, Ehrenamt oder sonstiges soz. Engagement, Teilnahme an Messen/Events 

#####Homophilie
-->**Wirkung**: "die Liebe zum Gleichen", positive Sozialbeziehungen bilden sich tendenziell eher, wenn die Einstellungen von Akteur*innen √ºbereinstimmen oder sie zu den gleichen sozialen Kategorien dazugeh√∂ren (z.B. soziale Schicht)
-->**Bsp**.: politische Einstellung, religi√∂se Einstellung (Werte-Homophilie / Einstellungs-Homophilie), Ethnie, Mistudierende Unis/Hochschule/Berufsschule, die sich im gleichen Studiengang befinden und sich darum mit den gleichen Inhalten auseinandersetzen 

#####Orientierung an Institutionen & Rollen 
-->**Wirkung**: die Bildung von Beziehungen und deren Konstellationen folgen meistens vorgegebenen kulturellen Strukturen oder formalen (gesellschaftlichen) Strukturen
-->**Bsp.**: Untersagung Liebesbeziehung zw. Dozierenden & Studierenden, Heirat: von Gesellschaft vorgeschriebene Ideale, wen man heiraten soll (z.B. in den 1960ern Ideal, dass Frau einen reichen Mann heiratet)

####Netzwerkstrukturierung

#####Reziprozit√§t
-->**Wirkung:** bestimmte Sozialbeziehungen tendieren dazu, wechselseitig zu sein
-->**Bsp.:** Freundschaften, Liebesbeziehungen vs. Verliebtsein (kann auch einseitig sein)

#####Transitivit√§t
-->**Wirkung:** Tendenz zu ausgeglichenen, ausbalancierten Beziehungen, v.a. bei Triaden (bspw. entweder alle drei Bez. positiv, oder eine positive und zwei negative Bez.)
-->**Bsp.:** A und B sind jeweils mit C befreundet, was wiederrum  die Wkeit erh√∂ht, dass A und B sich dann auch anfreunden --> C als Broker 

#####Preferential Attachment
-->**Wirkung:** Akteur*innen bilden oft Beziehungen zu im Netzwerk zentralen Akteur*innen, wird auch als Matth√§us-Effekt bezeichnet --> "Wer da hat, dem wird noch gegeben", wenn jmd. also viel Sozialkapital hat, bekommt er oder sie meist noch mehr davon  
-->**Bsp.:** Fu√üball --> Spieler*in mit h√∂chster Passqualit√§t wird am ehesten angespielt, Schule --> man will mit dem*der Beliebtesten befreundet sein, Influencer*innen -->Orientierung an z.B. Style, Politik --> Parteimitglieder h√§ngen sich an einflussreiche Politiker*innen 
-->**Beachte Prefertial Attachment in umgekehrter Richtung**: hohes Sozialkapital kann auch wieder genommen werden: Kanye West--> nach dessen antisemitischen √Ñu√üerungen haben adidas und weitere Marken Kooperationen mit ihm wieder gek√ºndigt 

####Netzwerkeffekte

#####Zugang zu Informationen
-->**Wirkung:** Akteur*innen mit im Netzwerk zentralen Positionen erhalten Informationen fr√ºher als andere, da sie meist k√ºrzere Pfaddistanzen haben 
-->**Bsp.:** Uni-->Semestersprecher*in, Studiendekan*innen, Unternehmenswelt --> Management, Sekretariat 

#####Macht
-->**Wirkung:** Broker*innen in einem Netzwerk haben oft Macht und auch solche Akteur*innen, von denen die Alteri abh√§ngig sind, was diesen Akteur*innen einen Einfluss darauf gibt, was im Netzwerk passiert 
-->**Bsp.:** Arbeitsleben --> Chef*innen, Manager*innen, h√∂chste Etage in Unternehmen, drittes Reich -->Hitler, Medici in Florenz (damit sie Strippen ziehen k√∂nnen, m√ºssen sie Broker im Netzwerk sein) 
-->**Beachte:** Broker m√ºssen nicht unbedingt Akteur*innen an der Spitze eines Netzwerkes sein, sind aber immer diejenigen, die die Infos gatekeepen k√∂nnen und somit Einfluss & Macht haben

#####Sozialer Druck 
-->**Wirkung:** Netzwerke mit einer besonders hohen Dichte f√ºhren dazu, dass sich Akteur*innen oft zwangsl√§ufig kooperativ verhalten m√ºssen und dazu, dass Ideen und Denkweisen zentraler Akteur*innen meist √ºbernommen werden (Gruppendynamik/ -zwang)
-->**Bsp.:** soziale Cliquen, enge Freundesgruppe, in der eine Person mglw. etwas andere Hobbies hat als der Rest, Sekten (z.B. Scientology), extremist. Gruppen / Gangs (lassen nur Beziehungen nach innen zu, nicht aber nach au√üen)

#####Soziale Kategorisierung 
-->**Wirkung:** in Netzwerken kann es auch zu strukturellen Separierungen von Akteur*innen kommen, v.a. bei unterschiedlichen Denk- und Lebensweisen. In solchen F√§llen teilen sich Netzwerke meistens in soziale Kategorien abbildende Cluster/Componeneten auf 
-->**Bsp.:** Echokammern versch. polit./religi√∂ser Glaubensrichtungen (bspw. progressiv vs. konservativ), Bildungssystem-->Gymnasium/Realschule/Hauptschule, 
soziale Schichteinordnung--> Unterschicht, Mittelschicht, Oberschicht

#####Koordination 
-->**Wirkung:** Dichte Netzwerke, die eine hohe Zentralisierung aufweisen, f√ºhren eher dazu, dass die Akteur*innen koordiniert handeln 
-->**Bsp.:** Arbeitsleben -->Teams, die dicht vernetzt sind (z.B. 360Grad-Feedback zw. Mitarbeitenden & F√ºhrungskr√§ften), Protestbewegungen (m√ºssen dicht vernetzt sein, um ihre Anliegen wirksam in die √ñffentlichkeit zu tragen)








#Teil 2: Netzwerkanalyse

## Codebuch f√ºr den hier verwendeten Datensatz CR/PR Semesterverbund

[Codebuch](https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md)

Das Netzwerk hat nach dem
[Codebuch](https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md)
folgende Attribute:

*Vertex-Attribute*

\- name: Name des Knotens, anonym codiert von 1 bis 38\
- sex: Geschlecht 1 weiblich, 2 m√§nnlich, 3 divers\
- crpr: Vertiefungsrichtung (1 CR, 2 PR)\
- age: Alter 1 bis 20, 2 21-22, 3 23-24, 4 25 und √§lter\
- age_real: tats√§chliche Altersangabe\
- smoke: Nichtraucher 1, Raucher 2\
- tatoo: nein 1, ja 2\
- eyes: Augenfarbe: 1 gr√ºn, 2 blau, 3 braun, 4 blau.\
- hair: Haarfarbe: 1 braun, 2 schwarz, 3 blond, 4 rot

Die Vertex-Attribute treffen auf alle Knoten zu.

*Edge-Attribute*\
- weight: Erste Nennung (Prim√§rer Kontakt). Zweite Nennung (Sekunder√§rer
Kontakt)\
- relation: Ratsuche (help), Zusammenarbeit (work), Liebesbeziehung
(love)\
- complicated: bezieht sich nur auf das Teilnetzwerk Liebesbeziehung

Die Edge-Attribute sind unterschiedlich verteilt. Durch die Erhebung
haben die Studierenden ein Ratsuchenetzwerk (Wen fragst Du um Rat?) und
ein Zusammenarbeitsnetzwerk (Mit wem arbeitest Du am liebsten zusammen?)
angeben m√ºssen. F√ºr beide Fragen gab es eine erste und ein zweite
Nennung. Die erste Nennung wird entsprechend h√∂her gewichtet. Die Fragen
waren verpflichtend. Das bedeutet, dass die Edges sich wie folgt
verteilen: 38\*2 = 76 Beziehungenangaben f√ºr jeweils help und work.

##Logische Operatoren

```{r Logische Operatoren, echo=FALSE}

# Verkn√ºpfung mehrer logischer Operatoren
# == ist genau gleich
# != ist ungleich
# > gr√∂√üer, < kleiner, >= gr√∂√üer gleich, <= kleiner gleich
# & und im Sinne der Verkn√ºpfung von Werten innerhalb eines Befehls in einer Klammer ()
# | oder

#Achtung bei = oder == 
#pr√ºfen mit list.edge.attributes() bzw. edge.attributes()$attribut, ob die Werte numerisch (ohne Anf√ºhrungszeichen) oder als charakter (dann mit Anf√ºhrungszeichen) ausgegeben werden. 
 

#Anmerkung: filter(!is.na(height)) bedeutet quasi ‚Äû Gr√∂√üe ist kein NA/schlie√üt NAs aus‚Äú

#NAs kann man allgemein auch mit drop_na rausnehmen
#ist egal, an welcher Stelle man drop_na bei l√§ngerer Code-Befehlskette hinschreibt
#dazu dann aber library(tidyverse) vorher noch in Chunk runnen

```


## Gesamtnetzwerk f√ºr die Analyse vorbereiten

```{r Gesamtnetzwerk erstellen, echo=FALSE}

library(igraph)

# Einlesen der Edge- und Nodelist

#Edgelist einlesen 
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen 
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

# Matrix erstellen / Edgematrix erstellen 
edgematrix <-as.matrix(el)

# Zusammenf√ºhren von Edge- und Nodelist als igraph-Objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s


```

## Deskriptive Netzwerkanalyse

-->**Anzahl Knoten**
-->**Anzahl Kanten**
-->**gerichtet/ungerichtet**
-->**gewichtet/ungewichtet**
-->**Anzahl Komponenten**
-->**Triadenzensus**
-->**Dyadenzensus**
-->**One-Mode-Netwerk/Two-Mode-Netzwerk**

```{r A Deskriptive Netzwerkanalyse}

#nicht notwendig, aber hilfreich: 
E(s) #Edgelist-Beziehungen anzeigen
V(s) #Nodelist-Angaben anzeigen

# Anzahl Knoten
vcount(s) #38

# Anzahl Kanten
ecount(s) #176

# gerichtet/ungerichtet
is.directed(s) #TRUE, also gerichtet

# gewichtet/ungeweichtet
is.weighted(s) #TRUE, also gewichtet

# Anzahl Komponenten
is.connected(s) #FALSE, also sind die Komponeneten nicht miteinander verbunden
count_components(s)
components(s) #2 Komponenten, eine mit 32 Knoten, die andere mit 6 Knoten

# Um genauer zu verstehen, welche Vertices zu welcher Gruppe geh√∂ren, lassen sie sich mit dem Befehl groups(g) in Grupppen unterteilten. 
s_groups <- groups(components(s))
s_groups #in Konsole werden die Knoten jeweils mit Zugeh√∂rigkeit zu Komponente 1 oder Komponente 2 angezeigt

# Triadenzensus
#Der Befehl
#triad_census(a) liefert Ihnen folgendes Ergebnis:
# [1] 96785 15350   286   402   741     0     0     0     0     0     0     0     0
#[14]     0     0     0
#Die 16 ausgegebenen Werte bedeuten, dass alle 16 Triaden-Typen im Netzwerk durchsucht wurden. Die 16 Typen finden Sie √ºber die  Hilfsfunktion ?triad_census() bzw. in der Tabelle von Fuhse 2018. 
#Die Werte werden jetzt von links nach rechts gelesen, d.h. nur  die ersten 5 Typen liegen im Netzwerk vor, es gibt z.B. keine Cliquen (Typ 300 = 0) 
#Nummer, die da vom Typ steht, gibt an, wie oft der Typ vorkommt
?triad.census
triad_census(s) #3 reziproke Triaden, also 3 Cliquen im Netzwerk

#Dyadenzensus
?dyad.census
#mut/M	
#Die Anzahl der Paare mit gegenseitigen Verbindungen.

#asym/A	
#Die Anzahl der Paare mit nicht-gegenseitigen Verbindungen.

#null/N	
#Die Anzahl der Paare, zwischen denen keine Verbindung besteht.

dyad_census(s) #27 Paare mit gegenseitige/reziproke Verbindungen, 70 Paare mit asymmetrischen Verbindungen, 606 Paare mit nicht vorhandenen Verbindunegn

#one-mode/two-mode?
is_bipartite(s) #FALSE, also One-Mode-Netzwerk

```



## Parameter zur Beschreibung des Netzwerkes

Das Hauptnetzwerk besteht aus zwei Komponenten mit 32 und 6 Knoten, die
nicht miteinander verbunden sind. Die Dichte im Netzwerk betr√§gt 12,51
Prozent von allen m√∂glichen Verbindungen. Die maximale Pfaddistanz
betr√§gt 18 Schritte.

```{r Beschreibung des Netzwerks}
# Parameter zu Beschreibung des Netzwerks

## ist das Netzwerk bereits vereinfacht?
is.simple(s) #FALSE, also ist es nicht bereits vereinfacht

## besteht das Netzwerk aus Komponenten?
## wenn ja, wie vielen?
is.connected(s) #FALSE: die Komponeneten sind nicht miteinander verbunden
components(s) #2 Komponenten mit 32 und 6 Knoten

## Dichte des Netzwerks
edge_density(s, loops=FALSE) #0.1251778, also Dichte von 12,52 Prozent #Loops schlie√üt Knoten, die sich selbst angegeben haben, aus 

## Umfang des Netzwerks (am besten einfach die Funktion nehmen, um auf Nummer sicher zu gehen)
diameter(s) #18 --> Also Umfang von 18 Knoten

#alternativ: Umfang mit dem Befehl distances
#ACHTUNG: GIBT DANN ABER EINFACH DIE ENTFERNUNG VON KNOTEN ZU KNOTEN AN, ALSO NICHT DEN GRUNDS√ÑTZLICHEN UMFANG

#f√ºr ungerichtete Netzwerke 
#Quelle: ChatGPT 2023, Prompt 1 "Kann man den den Befehl distance in graph verwenden, um den Umfang eines Netzwerkes zu berechnen?", Prompt 2 "Kann ich auch den Befehl distance(g, v = V(g), mode = "all") nutzen, um den Umfang eines Netzwerkes in igraph zu berechnen?", Prompt 3 "Kann ich auch einfach nur den Befehl distance(g) verwenden, um den Umfang eines Netzwerkes in igraph zu berechnen?"; Prompt 3 hat zu dieser Antwort gef√ºhrt in Kombination mit ?distances in RStudio

?distances
is.directed(s)
distances(s, v = V(s), mode = "all")

#f√ºr gerichtete Netzwerke 
is.directed(s)
distances(s, v = V(s), mode = "out")

## Pfaddistanzen (Distance)
farthest_vertices(s) #18 --> Also Pfaddistanz von 18, also durchschnittliche Entfernung von 18 Schritten, und zwar von Knoten 3 zu 33, d.h. Knoten 3 und 33 sind im Netzwerk am weitesten voneinander entfernt


```



### Netzwerke vereinfachen

Es ist sinnvoll, ein vereinfachtes Gesamtnetzwerk zu erstellen.
**Vereinfacht** bedeutet, dass die unterschiedlichen Beziehungsarten
ignoriert werden und daf√ºr die **Gewichte des Hilfs- und Ratsuche
Netzwerk zusammengefasst** werden (um das Ergebnis nicht zu verf√§lschen,
wird das Beziehungsnetzwerk vorher gel√∂scht)

#### Vereinfachtes Netzwerk mit Befehl simplify()

Achtung: die Bereinigung hier bezieht sich nur auf mehrfache Beziehungen
und Loops. 
--> Wenn Sie Netzwerke mit mehrfachen Beziehungen (multiplexe
Netzwerke) verwenden, ist die notwendig, diese Schritte f√ºr die
verschiedenen Beziehungsarten durchzuf√ºhren 
--> oder mit Teilnetzwerken zu
arbeiten.

Die Anzahl der Knoten ist gleich geblieben (38), aber die Anzahl der
Kanten hat sich auf 124 reduziert. 
--> Das sieht man, indem man in der Konsole bei der Anzeige des Netzwerks in der ersten Zeile die Werte anguckt: erster Wert ist Anzahl Knoten, zweiter ist Anzahl Kanten IGRAPH 8786d14 DNW- 38 124 -- 

Die Verteilung des Gewichts l√§sst
klare Pr√§ferenzen innerhalb des Netzwerks zwischen einzelnen Dyaden
zeigen. Diese Vorselektion ist sp√§ter wichtig, um starke Beziehungspaare
innerhalb des Netzwerks zu analysieren.

```{r Vereinfachtes Gesamtnetzwerk erstellen mit simplify}

# Gesamtnetzwerk erstellen
# Der Code wird hier nur eingef√ºgt, falls der Chunk sp√§ter alleine weiterverwendet wird.

library(igraph)

#Edgelist einlesen

el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen

nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen

edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-Objekt s

s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Edge-Attribute anzeigen lassen 

list.edge.attributes(s) #Edge-Attribute weight, realtion, complicated

# simplify Gesamtnetzwerk 
# Um die Ergebnisse der Gewichte nicht zu verf√§lschen, werden die Edge-Attribute relation und complicated gel√∂scht.

#neue Netzwerke erstellen, aus denen die entsprechenden Edge-Attribute gel√∂scht sind 
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
list.edge.attributes(ss) #jetzt nur noch Edge-Attribute weight und relation

# mit dem Befehl simplify() lassen sich Edge-Attribute wie das Gewicht zusammenfassen. Damit ist zwar nicht mehr nachvollziehbar, um welche Beziehung es sich handelt. Daf√ºr lassen sich die Beziehungsst√§rken aber besser abbilden. Dies ist sp√§ter f√ºr die Analyse von dyadischen Beziehungen wichtig.

is_simple(ss)
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
is_simple(s_sim) #jetzt vereinfachtes Netzwerk
s_sim

# die aggregierten Werte f√ºr weight von s_sim werden deutlich.
list.edge.attributes(s_sim)
edge.attributes(s_sim)$weight #nur das Edge-Attribut weight anzeigen lassen

# Hat das Netzwerk Componenten?
is_connected(s_sim)

```

### Teilnetzwerke erstellen 


#### **Nur starke Beziehungen im Gesamtnetzwerk**

-->igraph: **Name Teilnetzwerk <- subgraph.edges(Netzwerk, E(Netzwerk)[ausgew√§hltes Attribut==Codierung])**

F√ºr dieses Netzwerk sollen nun nur noch starke Beziehungen mit einem
Gewicht von \>= 6 angezeigt werden. Damit wird das Netzwerk in ein neues
Teilnetzwerk zerlegt, das nur noch aus starken Beziehungen besteht:

```{r Starke Beziehungen im Gesamtnetzwerk, fig.height=4, fig.width=6}

# erstellt ein Teilnetzwerk nur aus starken Beziehungen
s_sim_strong <- subgraph.edges(s_sim, E(s_sim)[weight>=6]) 
s_sim_strong

#Anzahl Knoten
vcount(s_sim_strong) #25 Knoten mit starken Beziehungen

#Anzahl Kanten
ecount(s_sim_strong) #20 starke Verbindungen

#das Edge-Atrribut weight / Gewicht des Teilnetzwerkes s_sim_strong anzeigen lassen 
edge.attributes(s_sim_strong)$weight

plot(s_sim_strong,
     asp=0,
     layout=layout_with_kk,
     vertex.size=10,
     vertex.frame.color=NA,
     vertex.color="lightgreen",
     vertex.label.color="grey20",
     vertex.label.cex=1,
     edge.arrow.size=2,
     edge.color="lightgreen",
     edge.width=E(s_sim_strong)$weight/2, #halbiert das Gewicht zur besseren √úbersicht
     edge.curved=.3,
     edge.curved=curve_multiple(s_sim_strong),
     main = "Gesamtnetzwerk: Starke Beziehungen", 
      sub = "Gewicht >= 6",
      cex.main = 1, col.main= "black",
      cex.sub = 1, font.sub = 3, col.sub = "black")


#weitere Teilnetzwerke erstellen 

library(igraph)

#Edgelist einlesen

el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")


#Nodelist einlesen 

nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen 

edgematrix <-as.matrix(el)

#Edge- und Noelist zusammenf√ºhren als igraph-Objekt s

s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Edge-Attribute anzeigen lassen
list.edge.attributes(s) #weight, relation, complicated

#Teilnetzwerke erstellen

#Teilnetzwerk work nach geringer Zusammenarbeit ausw√§hlen

work <- subgraph.edges(s, E(s)[relation==1]) 
work

#Teilnetzwerk help nach mittlerer Ratsuche ausw√§hlen 

help <- subgraph.edges(s, E(s)[relation==2])
help

#Teilnetzwerk love nach starker Gewichtung / einseitige Verliebtheit crush ausw√§hlen
love <- subgraph.edges(s, E(s)[relation==3])
love

work # das Netzwerk hat nur noch 76 Kanten (also 2*38 Antworten)

# ebenfalls eigenst√§ndige Teilnetzwerke sind
# help
# love



```


#### Farbliche Hervorhebung von besonders wichtigen Knoten

```{r Hervorhebung der popul√§rsten Knoten im Netzwerk, fig.height=4, fig.width=6}

# mit der Auswahl der Knoten lassen sich deren Rahmenfarben spezifisch angeben -->sind dann dauerhaft so festgelegt
V(s_sim)[V(s_sim)$name == 6]$color <- "green" # Name des Knoten 6 des Teilnetzwerkes ist jetzt gr√ºn
V(s_sim)[V(s_sim)$name == 18]$color <- "red"#Name des Knoten 18 des Teilnetzwerkes ist jetzt rot

#sind in Visualisierung dann farblich hervorgehoben

plot(s_sim,
     layout=layout_in_circle,
     vertex.size=degree(s_sim),
     vertex.label.cex=1,
     vertex.frame.color=NA,#(muss ausgeschaltet sein, damit die Knoten visualisiert werden k√∂nnen
     edge.arrow.size=.5,
     edge.color="grey80",
     edge.width=E(s_sim)$weight/2, #halbiert den Wert der Gewichte, um eine bessere Darstellung zu erm√∂glichen
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     main = "Gesamtnetzwerk vereinfacht", 
      sub = "beliebteste Knoten in gr√ºn (st√§rkste Beziehungen) und rot (h√∂chste Degrees)",
      cex.main = 1, col.main= "black",
      cex.sub = 1, font.sub = 3, col.sub = "black")


```


#### Attribute anzeigen lassen

```{r Auslesen von Attributen}

#Liste aller Kanten- und Knotenattribute

#Node Attribute anzeigen 
list.vertex.attributes(s)

#Ege Attribute anzeigen
list.edge.attributes(s)

#Anzahl Edges und Vertices 
ecount(s) #176 Das Netzwerk hat Edges
vcount(s) #38 Das Netzwerk hat Vertices 

#Koppelbefehl, um Vertex Attribute miteinander zu koppeln oder auszuw√§hlen
vertex.attributes(s)

# Beispiel f√ºr das Vertex-Attribut Geschlecht

#Vertex-Attribut Geschlecht anzeigen lassen 
vertex.attributes(s)$sex


#Koppelbefehl, um Edge Attribute miteinander zu koppeln oder auszuw√§hlen
edge.attributes(s)


#Edge-Attribut Gewicht anzeigen lassen
edge.attributes(s)$weight


#Wert Gewicht in der Edgelist ausw√§hlen
edge.attributes(s)$weight

#Wert Beziehung in der Edgelist ausw√§hlen
edge.attributes(s)$relation

#Wert Geschlecht
edge.attributes(s)$sex

# wichtig: sind keine Werte gesetzt, dann behandelt igraph den Wert als NA, also not available. Das ist wichtig f√ºr die Kalkulation der Netzwerkbeziehungen. Complicated ist ein Wert der sich nur auf das Teilnetzwerk love bezieht und spielt deshalb f√ºr die anderen 2x76 Beziehungen keine Rolle. 

```

###Netzwerkattribute festlegen 

Netzwerkattribute sind hilfreich, um Netzwerke besser zu verstehen. Sie sind wichtige Parameter f√ºr die sp√§tere Visualisierung von Netzwerken. Jedes Netzwerk hat zus√§tzlich zu den erhobenen Attributen feststehende Visualisierungsparameter. Diese lassen sich beliebig manipulieren. 

-->Werden die Daten ein Mal festgeschrieben, dann gelten sie f√ºr alle weiteren Netzwerke. 

-->**Merke:**
  -->Die Befehle **V(Netzwerk)** und **E(Netzwerk)** erstellen dauerhaft neue Vertex bzw. Edge-Attribute, die mit bestimmten Eigenschaften versehen werden k√∂nnen. 
  -->Mit $ wird auf die entsprechenden Attribute zugegriffen.
  -->Die Attribute lassen sich auch durch "NA" komplett l√∂schen oder durch ein bestehendes Attribut wieder erg√§nzen. 

Beispielsweise wird hier die F√ºllfarbe eines Knotens auf dunkelorange definiert V(s)$color<-"darkorange". Mit vertex.attributes(Netzwerk)$color kann dieser Wert angezeigt werden. 
Der Rahmen eines Knoten kann durch die Zuweisung des Wert "NA" ausgeblendet werden V(Netzwerk)$frame.color<-"NA". Dies gilt auch f√ºr Kantenattribute. Beispielsweise lassen sich die Pfeilspitzen auf den Wert .2 setzen E(s)$arrow.size<-.2 oder die Farbe der Kanten entsprechend festlegen E(s)$color<-"darkorange"

Manchmal ist es hilfreich die Labels auszublenden V(s)$label<-NA. Um diese wieder herzustellen das Vertex-Attribut "Label" mit dem Wert des Vertex-Attributs "Name" wieder √ºberschrieben: V(s)$label<-V(s)$name. 
Eine √úbersicht aller Edge- und Vertex-Attribute, die mit diesen Befehlen ver√§ndert werden k√∂nnen liefert die Hilfefunktion ?igraph.plotting

```{r Netzwerkattribute_manipulieren}

?igraph.plotting

#Uerspruengliche Visualisierung 

V(s)$color <- "darkorange" #Knoten sind darkorange
V(s)$frame.color <- "NA"   #keine Rahmenfarbe
E(s)$arrow.size <- .2      #Pfeile auf .2 klein
E(s)$color <- "darkorange"  #die Kanten sind auch dunkelorange

plot(s,
     layout=layout_with_kk,
     main ="Visualisierung mit ge√§nderten Attributen")

#Neue Visualisierung mit geanderter Farbe, Ueberschrift und Pfeilspitzen

V(s)$color <- "darkblue"        #Kanten sind jetzt dunkelblau
V(s)$frame.color <- "lightblue"#Rahmenfarbe der Knoten hellblau
E(s)$arrow.size <- .3          #Kantengr√∂√üe .3 klein 
E(s)$color <- "lightblue"      #Kanten hellblau 

plot(s,
     layout=layout_with_kk,
     main ="Datensatz Semesterverbund CRPR2 mit farblicher Gestaltung",
     sub = "Daten zu den Beziehungen der Studierenden")

```


#### Unnutzbare / f√ºr Teilnetzwerk irrelevante Edge-Attribute im Teilnetzwerk l√∂schen

```{r unnutzbare Edge-Attribute im Teilnetzwerk l√∂schen}

library(igraph)

# Nicht ben√∂tigte Edge-Attribute l√∂schen
# In den Teilnetzwerken sind edge-Attribute vorhanden, die wir f√ºr eine weitere Vereinfachung des Netzwerks nicht ben√∂tigen. Das gilt v.a. f√ºr die Teilnetzwerke work und help.

#Edge-Attribut relation l√∂schen
work <- delete_edge_attr(work, "relation")

#Edge-Attribut complicated l√∂schen
work <- delete_edge_attr(work, "complicated")

#Edge-Attribut relation l√∂schen
help <- delete_edge_attr(help, "relation")

#Edge-Attribut complicated l√∂schen
help <- delete_edge_attr(help, "complicated")

love <- delete_edge_attr(love, "relation")
# bei love bleibt die Kategorie complicated erhalten, da sich diese ja direkt auf die Art der Liebesbeziehung bezieht. Bei erstellten Liebesnetzwerk werden auch alle Knoten gel√∂scht, die keine Beziehungskategorie haben, d.h. das Netzwerk ist automatisch kleiner. 

#Edge-Attribut complicated des Teilnetzwerkes love anzeigen lassen
edge.attributes(love)$complicated

# mit dem Befehl simplify() lassen sich Edge-Attribute wie das Gewicht zusammenfassen. Damit ist zwar nicht mehr nachvollziehbar, um welche Beziehung es sich handelt. Daf√ºr lassen sich die Beziehungsst√§rken aber besser abbilden. Dies ist sp√§ter f√ºr die Analyse von dyadischen Beziehungen wichtig.
# 
is_simple(work)
w_sim <- simplify(work,edge.attr.comb=list(weight="sum"))
is_simple(w_sim)
w_sim

is_simple(help)
h_sim <- simplify(help,edge.attr.comb=list(weight="sum"))
is_simple(h_sim)
h_sim


```


#### Vergleich von Teilnetzwerken 


```{r Vergleich der drei Netzwerke, paged.print=TRUE}

# Vergleich der drei vereinfachten Netzwerke
# wir legen die Parameter der Visualisierung fest
# mfrow definiert, dass es eine Zeile mit drei Spalten sein soll
#also generell par(mfrow=c(Anzahl Zeilen, Anzahl Spalten))
#man muss f√ºr Visualisierung nebeneinander alles von par bis zu den Plots einschlie√ülich markieren und dann runnen
# mar steht f√ºr margins und legt fest, 
par(mfrow=c(1,3), mar=c(2,0,2,0)) 

#Visualisierung vereinfachtes work Teilnetzwerk
plot(w_sim, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="blue",
     edge.width=E(w_sim)$weight, #Breite orientiert sich am Gewicht des Netzwerkes
     vertex.color="grey75",
     vertex.frame.color=NA,
     main=" Teilnetzwerk: Zusammenarbeit",
     sub="38 Knoten mit 75 Kanten")

#Visualisierung vereinfachtes help Teilnetzwerk
plot(h_sim, layout=layout_with_kk, 
     edge.arrow.size=.2,
     edge.color="green",
     edge.width=E(h_sim)$weight,
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Teilnetzwerk: Ratsuche",
     sub="38 Knoten mit 75 Kanten")

#Visualisierung love Teilnetzwerk 
plot(love, layout=layout_with_kk, 
     edge.arrow.size=.2,
     edge.color="red",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Teilnetzwerk: Liebe",
     sub="23 Knoten mit 24 Kanten")

# setzt die Darstellung wieder auf eine Abbildung zur√ºck
par(mfrow=c(1,1), mar=c(0,0,0,0))

```

#### Teilnetzwerken nach Gewichtung der Beziehungen im Vergleich 
Eine weitere Form der Analyse w√§re es, die Teilnetzwerke work oder help
nach der ersten und zweiten Nennung zu unterteilen. Die Annahme ist,
dass die erste Nennung (und damit das Kantengewicht 3) eine h√∂here
Popularit√§t hat als die zweite Nennung. So lassen sich ggf.
Pr√§ferenzdynamiken innerhalb des Netzwerks aufzeigen.

**Ergebnisse der Analyse**

Interessant in der Analyse ist, dass die bis dahin zweite Komponente aus
den Knoten 5,6,12,14,22,26 bei der ersten Nennung noch zusammenbleibt,
bei der zweiten Nennung aber in zwei kleinere Komponenten zerf√§llt
(5,22) und (6,12,14,26). Das bedeutet, dass die Dyade 5 und 22 sich
sowohl bei der ersten als auch zweiten Nennung beides mal genannt hat.
Folglich m√ºsste das Gewicht des aufaddierten Netzwerks bei dieser Dyade
den Wert 6 haben.

Ingesamt zeigt die Analyse, dass die Pr√§ferenzen f√ºr die Zusammenarbeit
sich deutlich st√§rker zerlegen l√§sst, wenn man die Teilnetzwerke nach
Gewicht erhebt.

```{r Teilnetzwerke anhand des Kantengewichts vergleichen}

library(igraph)

#Edgelist einlesen 

el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen 
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s 
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Edge-Attribute anzeigen lassen 
list.edge.attributes(s) #weight, relation, complicated

#schwache Gewichtung f√ºr Teilnetzwerk work ausw√§hlen
work <- subgraph.edges(s, E(s)[relation==1]) 

# unn√∂tige Edge-Attribute entfernen #brauche ich im Testat nicht
work <- delete_edge_attr(work, "relation")
work <- delete_edge_attr(work, "complicated")


#neue Liste Edge-Attribute anzeigen lassen
list.edge.attributes(work) #nur noch das Edge-Attribut weight

#Edge-Attribut Gewicht ausw√§hlen
edge.attributes(work)$weight

# aggregiertes Netzwerk #brauche ich im Testat nicht
is_simple(work)
ws <- simplify(work,edge.attr.comb=list(weight="sum"))
is_simple(ws)
ws

# unterteilt das Netzwerk in das Hilfsnetzwerk h1 mit einem Gewicht von 1
w1 <- subgraph.edges(work, E(work)[weight==1])
# analog dazu das Hilfsnetzwerk mit einem Gewicht von 3
w3 <- subgraph.edges(work, E(work)[weight==3])
# Vergleich der beiden Netzwerke

# jedes Netzwerk hat jetzt genau 38 Knoten mit 38 Kanten

# definiert, dass 3 plots in einer Zeile stehen
par(mfrow=c(1,3), mar=c(0,0,3,0)) 

plot(w3, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="darkblue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="starke Zusammenarbeit, \n Gewicht 3")

plot(w1, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="lightblue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Zusammenarbeit, \n Gewicht 1")

plot(ws, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="blue",
     edge.width=E(s)$weight, # definiert die Kantenstarke nach Gewicht
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Zusammenarbeit, \n simplifiziert, gewichtet")


# setzt die Ansicht wieder auf einen Graph pro Zeile zur√ºck
par(mfrow=c(1,1), mar=c(0,0,1,2))

```


#### Teilnetzwerk Beziehung im Vergleich 

**Ergebnisse der Analyse**

Durch die Teilnetzwerke wird deutlich, dass bei den **Paarbeziehungen**
zwei (unvollst√§ndige) Triaden vorliegen (16,28,29) und (6,5,22).
Entweder haben 28 und 5 jeweils eine Aff√§re oder sie neigen zur
Polyamorie. Die **Tinder-Beziehungen** (swipes) scheinen nicht stark
ausgepr√§gt zu sein (4 von 38 Befragten haben angegeben, dass sie auf
Tinder aktiv sind). Davon m√∂gen sich 33 und 9 gegenseitig auf Tinder und
sind auch in einer Beziehung. 31 findet 19 attraktiv, aber nicht
umgekehrt. Sehr begehrt im Semester scheint Knoten 23 zu sein, der f√ºnf
(heimliche) crushes hat. Knoten 23 findet aber wiederum 17 interessant.
Knoten 6 hat zwei crushes. Knoten 16 mag Knoten 18, aber Knoten 18
findet wiederum Knoten 23 attraktiv: eine vertrackte Situation!

```{r Teilnetzwerk love anhand des Kantengewichts vergleichen}

library(igraph)

#Edgelist einlesen 
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen 
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Edge-Attribute anzeigen lassen 
list.edge.attributes(s) #weight, relation, complicated

#Teilnetzerk love nach starker Beziehung ausw√§hlen
love <- subgraph.edges(s, E(s)[relation==3]) 
love
list.edge.attributes(love) #weight, relation, complicated

# Das Attribut "complicated" gibt drei Beziehungsarten an, mit denen das Netzwerk weiter unterteilt werden kann.

# Paarbeziehung im Netzwerk love
l_pair <- subgraph.edges(love, E(love)[complicated==1])
# Tinder-Swipe im Netzwerk love
l_tinder <- subgraph.edges(love, E(love)[complicated==2])
# Crush im Netzwerk love
l_crush <- subgraph.edges(love, E(love)[complicated==3])

# Vergleich der vier Netzwerke
#ist jetzt hier einfach aus Konsole abgelesen, kann man aber besser mit Code nochmal mit vcount und ecount f√ºr die jeweiligen Teilnetzwerke machen 
love #23 Knoten und 24 Kanten 
l_pair #12 Knoten und 12 Kanten --> also insgesamt 6 reziproke Paarbeziehungen
l_tinder #4 Knoten und 3 Kanten 
l_crush #11 Knoten und 9 Kanten

# definiert, dass 3 plots in einer Zeile stehen
par(mfrow=c(1,4), mar=c(0,0,4,0)) 

plot(love, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="darkblue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="alle Beziehungen")

plot(l_pair, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="red",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Paarbeziehungen")

plot(l_tinder, layout=layout_with_kk,
     edge.arrow.size=.5,
     edge.color="pink",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Tinder-Swipe")

plot(l_crush, layout=layout_with_kk,
     edge.arrow.size=.5,
     edge.color="lightgreen",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Crush")

# setzt die Ansicht wieder auf einen Graph pro Zeile zur√ºck
par(mfrow=c(1,1), mar=c(0,0,1,2))

```


#### Anderes Label als ID anzeigen lassen 

**Paarbeziehungen mit Namen anzeigen lassen**

Manchmal wollen wir nicht die Knoten-IDs anzeigen lassen, sondern ein
anderes Label, das wir zuvor den Knoten vergeben haben, z.B. eine
Abk√ºrzung oder nur einen Vornamen.

**Ergebnisse der Analyse**

Mit der **Detailanalyse** lassen sich viel mehr Informationen √ºber die
Knoten visualisieren und auch somit schneller interpretieren: Die einzig
heterosexuelle und monogame Beziehung ist zwischen Maria und Ahmed.
Clara findet zwar Karl gut, aber die Beziehung ist nicht reziprok.
Daniel und Andrea haben auch eine monogame Beziehung, wobei Andrea nicht
als bin√§r definiert ist. Eine polyamore Beziehung hat Anna, die sowohl
mit Ruht als auch mit Yara eine Beziehung hat, Yara und Ruth aber
untereinander nicht. Interessant ist die Triade um Maris, einer
nicht-bin√§ren Person, die sowohl mit Dejan aber auch mit Sina eine
Beziehung f√ºhrt.

```{r Paarbeziehungen mit Namen im Label, fig.height=4, fig.width=6}

# Zeige die Vertex-Attribute f√ºr das Teilnetzwerk Libes-Paarbeziehung
list.vertex.attributes(l_pair)

# Wir zeigen die Vornamen aus den Paarbeziehungen an
vertex.attributes(l_pair)$name_first

#Wir zeigen das Geschlecht aus den Paarbeziehungen an
vertex.attributes(l_pair)$sex

# wir √ºberschreiben den angezeigten label mit den Werten aus name_first --> bedeutet, dass ab jetzt die Vornamen anstatt der IDs angezeigt werden sollen
V(l_pair)$label <- V(l_pair)$name_first

# weist den Attributswerten entsprechende Farben und Formen zu

#Farben
V(l_pair)[V(l_pair)$sex == 1]$color <- "pink"
V(l_pair)[V(l_pair)$sex == 2]$color <- "lightblue"
V(l_pair)[V(l_pair)$sex == 3]$color <- "green" #divers

#Formen
V(l_pair)[V(l_pair)$sex == 1]$shape <- "square"  
V(l_pair)[V(l_pair)$sex == 2]$shape <- "circle"
V(l_pair)[V(l_pair)$sex == 3]$shape <- "rectangle" # divers

plot(l_pair, layout=layout_with_kk,
     edge.color="red",
     edge.arrow.size=.3,
     vertex.frame.color=NA,
		 vertex.label.cex=1,
     main="Paarbeziehungen mit Namen")
```


####Teilnetzwerk nach Node-Attributen 

Die Analyse der **Teilnetzwerke nach Node-Attributen** werden hier nur
exemplarisch am Beispiel Geschlecht und Vertiefungsrichtung gezeigt. Der
einfachste Weg, ein Teilnetzwerk zu erstellen geht √ºber den Befehl
delete.vertices(). Damit werden alle Knoten samt Kanten gel√∂scht, die
bestimmte Bedingungen erf√ºllen. Wenn die Node-Attribute numerisch
codiert sind, lassen sich logische Operatoren einsetzen.


#####Teilnetzwerk Geschlecht

**Ergebnisse der Analyse**

Bereits hier zeigt sich, dass das Netzwerk in **drei Komponenten**
zerf√§llt. Neben die zweite kleinere Komponente (die nur aus Frauen
besteht) kommt noch eine kleine Dyade (33,7) hinzu.

```{r Teilnetzwerk nach Node-Attribut Geschlecht, fig.height=4, fig.width=6}

#Vertex- / Node-Attribute ausw√§hlen
list.vertex.attributes(s)

#Node-Attrubut Geschlecht ausw√§hlen 
vertex_attr(s)$sex

# nur Frauen
#hier jetzt also alles l√∂schen, was nicht als weiblich codiert ist, da m√§nnlich als 2 und divers als 3 codiert ist, kann man hier den logischen Operator >1 verwenden, alternativ logischer Operator !=1 
s_fem <- delete_vertices(s, V(s)[sex > "1"]) 
s_fem

#oder
s_fem <- delete_vertices(s, V(s)[sex != "1"]) 
s_fem


s_fem
plot(s_fem, 
		 asp=0,
		 layout=layout_with_kk,
     edge.color="grey20",
     edge.arrow.size=.3,
		 edge.width=E(s_fem)$weight,
     vertex.color="lightgreen",
     vertex.frame.color=NA,
		 vertex.size=degree(s_fem),
		 vertex.label.cex=1,
		 main="Gesamtnetzwerk: weibliche Akteure",
     sub="n=29, 110 Kanten")
```

####Kombination von Node-Attributen

-->**generell erst ein Teilnetzwerk erstellen und das dann im n√§chsten Schritt weiter eingr√§nzen**

In diesem Beispiel lassen sich z.B. Geschlecht und Vertiefungsrichtung
kombinieren. Die Analyse der jeweiligen Kategorien folgt dabei dem
Forschungsziel.

```{r Kombination Geschlecht und Vertiefungsrichtung, fig.height=4, fig.width=6}

#Node-Attribute anzeigen lassen
list.vertex.attributes(s)

#Netzwerk weibliche PR-Vertieferinnen
#am besten zuerst Teilnetzwerk Frauen erstellen 
#dann PR-Eingrenzung
#also generell erst ein Teilnetzwerk erstellen und das dann im n√§chsten Schritt weiter eingr√§nzen

# Zun√§chst werden alle Werte gel√∂scht, die nicht weiblich sind (eins ist als weiblich codiert, also logischer Operator wird > verwendet, d.h. es werden alle m√§nnlichen und diversen Knoten gel√∂scht)
#man will also nur weibliche Studierende n√§her analysieren
s_fem <- delete_vertices(s, V(s)[sex >"1"]) 

# alternativ w√§re auch der logische Operator ungleich m√∂glich, falls die Werte unterschiedlich skaliert sind:
#in dem Fall h√§tte man aber alle Werte au√üer 1 aka. weiblich

delete_vertices(s, V(s)[sex !="1"]) 

# Dann werden die Journalisten mit dem Wert eins 1 (weil 1 als CR Vertiefung codiert ist) aus dem Netzwerk s_fem gel√∂scht (in dem nur Frauen sind.)
#d.h., man will nur weibliche PR-Vertieferinnen
s_fem_pr <- delete_vertices(s_fem, V(s_fem)[crpr=="1"]) 
s_fem_pr #12 PR Vertieferinnen mit 32 Verbindungen zueinander

# Der plot verwendet nur wenig Anpassungen.

plot(s_fem_pr, 
		 asp=0,
     layout=layout_with_kk,
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.label.color="grey30",
     vertex.color="pink",
     vertex.frame.color=NA,
		 main="Netzwerk der PR-Vertieferinnen",
     sub="n=12, 32 Kanten, alle Beziehungsarten")
```

####Einsatz logischer Verkn√ºpfungen 

-->logische Operatoren s.separater Outline-Punkt ganz oben in Teil 2 der Outline 

```{r Einsatz logischer Verknp√ºfungen}

# Wir m√∂chten alle m√§nnlichen Studierenden, die Journalismus vertiefen:

# Alternative 1
#also erstmal alle Geschlechter l√∂schen, die nicht m√§nnlich sind 
s_male <- delete_vertices(s, V(s)[sex != "2"])

#dann alle Angaben l√∂schen, die nicht CR-Vertiefung sind
s_male_cr <- delete_vertices(s_male, V(s_male)[crpr=="2"]) 
s_male_cr

#Vornamen aller m√§nnlichen CR-Vertiefer anzeigen lassen
vertex.attributes(s_male_cr)$name_first #Karl, Daniel, Ben, Luca

#alle m√§nnlichen CR-ertiefer in Relation zur insgesamten Vertiefungsrichtungsangabe anzeigen lassen 
vertex.attributes(s_male_cr)$crpr

plot(s_male_cr,
		 main="M√§nnliche CR Vertiefer")

```

###Teilnetzwerk nach Edge-Attributen

-->Verf√ºgt das Netzwerk √ºber entsprechende Edge-Attribute list.edge.attributes() l√§sst sich das Netzwerk durch die Auswahl spezifischer Edge-Attribute und dem Befehl subgraph.edges() erstellen. 
-->Der Befehl erstellt ein komplettes Unternetzwerk mit allen Node-Attributen. 

-->Der Befehl subgraph.edges ist wie folgt aufgebaut:
**subgraph.edges(Netzwerk, E(Netzwerk)[Selektion des Attributs])** 
-->und liest sich wie folgt: Erstelle ein neues Netzwerk aus dem Netzwerk, indem das Netzwerk basierend auf dem logischen Operator aus dem Edge-Attribut von Netzwerk gew√§hlt wird.

-->Wichtig ist es hier, das Netzwerk neu zu benennen.

**Mit subgraph.edges**

```{r subgraph_edges}

library(igraph)

#Edgelist einlesen

el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen

nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen 
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenfuehren zu einem gerichtetetn Netzwerk
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Edge-Attribute anzeigen lassen 

list.edge.attributes(s)

#Den Wert Beziehung aus den Edge-Attributen ausw√§hlen 
edge.attributes(s)$relation

#Teilnetzwerk f√ºr eine projektbasierte Beziehung erstellen 

work <- subgraph.edges(s, E(s)[relation==1]) 
work

#Visualisierung Teilnetzwerk projektbasierte Beziehung

plot(work,
     edge.arrow.size=.3,
     layout=layout_with_kk,
     edge.color="blue",
     edge.curved=.2,
     edge.curved=curve_multiple(work),
     main="Teilnetzwerk Zusammenarbeit",
     sub="n=38, KK-Algorithmus")
```


**Mit L√∂schfunktion**

```{r Netzwerk einlesen und Teilnetzwerke erstellen}
library(igraph)

#Edgelist einlesen
edges <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T)

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(edges)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Vereinfachung Netzwerk
s <- simplify(s, remove.multiple = FALSE, remove.loops = TRUE) 
s

E(s)$arrow.size <- .2 # definiert die Pfeilspitze auf Gr√∂√üe .2
E(s)$color <- "gray80" # definiert die Farbe (80% Grau) f√ºr alle Kanten
E(s)$curved <- .2

plot(s, main="Gesamtnetzwerk")

#Teilnetzwerk help nach Edge-Attributen

#l√∂scht alle Nennungen mit Gewicht 1
help_strong <- help - E(help)[E(help)$weight=="1"] 
#l√∂scht alle mit Gewicht 3
help_weak <- help - E(help)[E(help)$weight=="3"] 

# Visualisierung im Vergleich
par(mfrow=c(1,2), mar=c(1,1,1,1)) 
plot(help_strong, main="Help (stark)", sub="erste Nennung")
plot(help_weak, main="Help (schwach)", sub="zweite Nennung")
par(mfrow=c(1,1), mar=c(1,1,1,1))


# Unterscheidung eines Gesamtnetzwerks nach der Farbe der Kanten

E(s)[E(s)$relation == 1]$color <- "red" # CR-Vertiefer sind rot
E(s)[E(s)$relation == 2]$color <- "blue" # PR-Vertiefer sind blau


# Visualisierung im Vergleich
plot(s, 
     layout = layout_with_fr,
     main="Multiplexes Netzwerk mit zwei Farben",
     sub="rot = CR-Vertiefer, blau = PR-Vertiefer")

# Wenn sie bereits die Gewichte im Netzwerk erfasst haben, lassen sich diese einfach in der Visualiserung darstellen: Dazu wird auf das edge.attribut E(s)$weight zur√ºckgegriffen. Dieser Wert l√§sst sich auch entsprechend manipulieren

# Visualisierung im Vergleich

par(mfrow=c(1,2), mar=c(1,1,1,1))

plot(s, 
     layout = layout_with_fr,
     edge.width=E(s)$weight, #zeigt den Wert des Kantengewicht in der Visualisierung an
     main="Gewichte direkt",
     sub="Gewicht direkt ausgelesen aus weight")

plot(s, 
     layout = layout_with_fr,
     edge.width=E(s)$weight*2, #mit Multiplikation
     main="Gewichte mit Faktor 2",
     sub="Gewicht mit Faktor 2 multipliziert") 

par(mfrow=c(1,1), mar=c(1,1,1,1))


```



####Kombination von Edge- & Nodeattributen 

Teilnetzwerke lassen sich auch aus einer Kombination von Edge- und
Node-Attributen erstellen. Dazu werden die oben genannten Schritte
kombiniert.

**Teilnetzwerk M√§nner im Hilfsnetzwerk im Altersvergleich**

Bei den j√ºngeren M√§nnern fragt 31 Knoten 11 um Rat, bei den √§lteren
M√§nnern fragt Knoten 9 Knoten 10 um Rat. Die isolierten Knoten fragen
weibliche Knoten um Rat.

```{r Teilnetzwerk M√§nner und Hilfsnetzwerk im Altervergleich}

# alle Schritte zur Erstellung des Teilnetzwerks

# 1. Netzwerk einlesen

library(igraph)

#Edgelist einlesen

el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen 
edgematrix <-as.matrix(el)

#Edge- und Nodelist als igraph-Objekt s zusammenf√ºhren
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# 2. Teilnetzwerk Ratsuche generieren #Edge-Attribut
help <- subgraph.edges(s, E(s)[relation==2])

# 3. M√§nner herausfiltern #Node-Attribut
vertex_attr(help)$sex
help_male <- delete_vertices(help, V(help)[sex != "2"]) 
help_male

# 4. Altersstruktur anzeigen #Node-Attribut

vertex.attributes(help_male)$age
# Hier bietet es sich an, das Netzwerk in zwei Teilnetzwerke zu unterteilen, damit das Netzwerk nicht zu un√ºbersichtlich wird.

#Edge-Attribut help Teilnetzwerk jung (Node-Attribut)
help_male_young <- delete_vertices(help_male, V(help_male)[age>"2"]) 
help_male_young


#Edge-Attribut help Teilnetzwerk alt (Node-Attribut)
help_male_old <- delete_vertices(help_male, V(help_male)[age<"3"]) 
help_male_old

# Visualisierung im Vergleich
par(mfrow=c(1,2), mar=c(0,0,4,0)) # definiert, dass 3 plots in einer Zeile stehen

plot(help_male_young, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="skyblue",
     vertex.color="skyblue",
     vertex.frame.color=NA,
     vertex.label.color="white",
     main="junge M√§nner auf Ratsuche")

plot(help_male_old, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="blue",
     vertex.color="blue",
     vertex.frame.color=NA,
     vertex.label.color="white",
     main="√§ltere M√§nner auf Ratsuche")

par(mfrow=c(1,1), mar=c(0,0,4,0))

```

###Teilnetzwerke zusammenf√ºhren
-->Zsmf√ºhren von Teilnetzwerken aus subgraph.edges(Netzwerk) ist einfach, wenn diese als igraph-Objekt vorliegen
-->dann werden die Teilnetzwerke nur addiert
-->**Achtung**: dabei werden alle Attribute doppelt angelegt
-->das eignet sich also nur zur Visualisierung

```{r Teilnetzwerke zusammenf√ºhren}

#Addition von Teilnetzwerken, wenn sie als igraph-objekt vorliegen

#hk <- h1 + h3

```

###√úbersicht: Gesamtnetzwerk, Teilnetzwerk, Ego-Netzwerk
-->**Gesamtnetzwerk**
-->**Teilnetzwerk**
  -->Componenten
  -->Cluster
  -->vertex attribute
  -->node attribute
-->**Ego-Netzwerk**
  -->ego: Akteur*in im Fokus
  -->alteri: andere Akteur*innen (,die mit ego verbunden sind)

###Unterschied Componenten, Cluster & Communities

**Componenten** sind die einzelnen Bestandteile eines Netzwerkes
--> sie beschreiben Elemente von Netzwerken, die **nicht miteinander verbunden** sind
--> wenn alle Knoten im Netzwerk miteinander verbunden sind, spricht man von der *Hauptkomponente*, dann besteht das (Gesamt-) Netzwerk also aus nur einer Componente
--> ein Netzwerk besteht also immer aus mindestens einer Componente
--> ein Netzwerk kann abh√§ngig von seiner Gr√∂√üe beliebig viele Componenten haben

**Communities** beschreiben Teilgruppen eines Netzwerkes.
--> sie beschreiben also **relevante gegenseitige Beziehungen** in einem Netzwerk
--> Communities k√∂nnen auch innerhalb einer Componenete bestehen
-->Communities sind also **miteinander verbundene Teilgruppen**

**Cluster** basieren auf Communities, d.h., man muss in einer Netzwerkanalyse zuerst Communities erstellen, damit man Cluster bilden kann
--> Cluster sind quasi **statsistisch relevante Analysen von Communities**


####Componenten 

Die Analyse hat Teilnetzwerke nach spezifischen Kriterien generiert.
Jedes Netzwerk verf√ºgt aber auch √ºber spezielle Eigenarten, wenn sich
Knoten nach bestimmten Kriterien zusammenfinden.

-->Auf der Ebene des Netzwerks sind die **Komponenten**: Wenn keine
isolierten Knoten existieren und alle Knoten in einem Hauptnetzwerk
verbunden sind, dann liegt ein Netzwerk mit einer Komponente vor. -->nur eine Komponenete und alle Knoten sind miteinander verbunden: **Hauptkomponente**
-->jedes Netzwerk hat also mindestens eine Komponente

-->Die Pr√ºfung erfolgt mit dem Befehl **is_connected(Netzwerk)**. 
-->Achtung: manche Berechnungen von Netzwerkma√üen sind nur bei Netzwerken m√∂glich, die aus
einer Komponente bestehen.

**Komponenten analysieren**
Mit der Visualisierung sehen wir, dass das Studierendennetzwerk aus zwei
Komponenten besteht: einer gro√üen Hauptkomponente und einer kleineren
Komponente aus sechs Knoten. Da insbesondere bei gro√üen Netzwerken die
Teilkomponenten nicht immer sichtbar sind, ist es hilfreich zu Beginn
der Analyse sich alle Komponenten anzeigen zu lassen Der Befehl groups() 
zeigt an, welche Knoten zu welcher Komponente geh√∂ren.
-->alternativ Anzeige √úberblick wieviele Komponenten mit wievielen Knoten: components()

```{r Komponenten analysieren}

#Teilgruppen verbunden oder unverbunden?
is.connected(s) #FALSE, also unverbundenes Netzwerk mit Komponenten

# Anzahl der Komponenten
count_components(s) #Es gibt im Gesamtnetzwerk 2 Komponenten
components(s)

# Um genauer zu verstehen, welche Vertices zu welcher Gruppe geh√∂ren, lassen sie sich mit dem Befehl groups(g) in Grupppen unterteilten. 
s_groups <- groups(components(s))
s_groups #in Konsole werden die Knoten jeweils mit Zugeh√∂rigkeit zu Komponente 1 oder Komponente 2 angezeigt

```

**starke und schwache Komponenten**

Netzwerke lassen sich in starke und
schwache Komponenten analysieren. Dazu pr√ºft man zun√§chst, ob es sich um
eine Komponente handelt und zerlegt diese dann in eine starke und
schwache Komponente. **Stark** bedeutet hier, dass es sich um einen
Teilcommunities mit einer **h√∂heren Dichte** handelt.

```{r Starke und schwache Komponenten}

# Unteranalyse der Hauptkomponente
is.connected(s) #FALSE, also unverbundene Komponenten

# Analyse der Verteilung der Komponenenten nach schwach und stark
components(s, mode = c("weak", "strong"))

# Analyse der starken Komponenten
components(s, mode = "strong") #9 Knoten innerhalb der 2 gro√üen Teilkomponenten

# Analyse der schwachen Komponenten
components(s, mode = "weak") #2 Knoten innerhalb der 2 gro√üen Teilkomponenten

# Anzahl der Komponenten
count_components(s) #2 Komponenten

# Aufteilung der Komponenten
comp_s <- components(s)
groups(comp_s) #in Konsole werden die Teilkomponenten 1 und 2 und ihre dazugeh√∂rigen Knoten angezeigt

```


*Cluster* 

**Ergebnisse der Analyse**

Die Analyse zeigt: das Netzwerk besteht aus zwei nicht miteinander
verbundenen Clustern, die aus 32 und 6 Knoten bestehen.

```{r Pr√ºfung verbundener Cluster}
# Anzahl der Clusters
clusters(s) #2 Cluster, eins mit 32, eins mit 6 Knoten

# Sind die Cluster miteinander verbunden?
is.connected(s) #FALSE, also nein, nicht miteinader verbunden

```

**Netzwerk in Komponenten zerlegen**

Um Netzwerke in einzelne
Componenten oder Cluster zu zerlegen verwenden wir den Befehl
**decompose.graph(Netzwek)**. Wir wissen, dass das Netzwerk zwei Cluster oder
Componenten hat, die ausgegeben werden. Danach lassen sich die Cluster
getrennt auftrennen, als neue igraph-Objekte umschreiben und
visualisieren.

```{r Komponenten berechnen und isolieren, fig.height=4, fig.width=6}

library(igraph)

# Netzwerk erstellen und vereinfachen

#Edgelist einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammmenf√ºhren zum igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# Vereinfachtes Hauptnetzwerk
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
is_simple(s_sim)
is_connected(s_sim)

# Anzahl der Clusters
clusters(s_sim) #2 Cluster, eins mit 32 und eins mit 6 Knoten

# Komponenten auftrennen
s_comp <- decompose.graph(s_sim)
s_comp #jetzt sieht man in Konsole, dass Komponente 1 32 Knoten mit 112 Beziehungen hat und Komponente 2 6 Knoten mit 12 Beziehungen

# Komponenten neu benennen
s_comp1 <- s_comp[[1]]
s_comp2 <- s_comp[[2]]

# neue Teilkomponenten analysieren
s_comp1 #32 Knoten mit 112 Kanten
s_comp2 #6 Knoten mit 12 Kanten

#alternativ auch mit vcount und ecount
vcount(s_comp1) #32 Knoten 
ecount(s_comp1) #112 Kanten

vcount(s_comp2) #6 Knoten 
ecount(s_comp2) #12 Kanten


# Die Komponenten in einer Visualisierung vergleichen

# Visualisierung im Vergleich
par(mfrow=c(1,2), mar=c(0,0,4,0)) # definiert, dass 3 plots in einer Zeile stehen

plot(s_comp1, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="gold",
     vertex.color="gold",
     vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Hauptkomponente")

plot(s_comp2, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="tomato",
     vertex.color="tomato",
     vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp2),
     main="kleinere Komponente")

par(mfrow=c(1,1), mar=c(0,0,4,0))

```

**Relevanz von Komponenten** 

Die Aufteilung in Komponenten ist wichtig, weil
dadurch Netzwerkma√üe beeinflusst werden.

**Ergebnisse der Analyse**
Beispielsweise zeigt die Berechnung der Dichte im Netzwerk, dass im
Gesamtnetzwerk s_sim eine Dichte von 8,8% vorliegt, die Hauptkomponente
aber eine Dichte von 11,92% und die Teilkomponente eine Dichte von 40%
besitzt. Dies bedeutet, dass die Teilkomponente deutlich st√§rker
vernetzt ist als die Hauptkomponente.

*Merke*: Bei der Berechnung von Netzwerkma√üen und deren Vergleiche immer
sicherstellen, dass die Bez√ºge der Netzwerke zueinander auch gewahrt
bleiben.

```{r Komponenten im Vergleich am Beispiel Dichte}

# Dichteberechnungen im Vergleich
edge_density(s_sim) #0.08819346, also Dichte von ca. 8,82 Prozent
edge_density(s_comp1) #0.1129032, also Dichte von ca. 11,29 Prozent
edge_density(s_comp2) #0.4, also Dichte von ca. 40 Prozent


```

####Cluster 

Innerhalb von Komponenten lassen sich verschiedene Teilcluster berechnen.
Wir verwenden daf√ºr die Hauptkomponente und berechnen Cluster innerhalb
der Komponente. Der *cluster_walktrap(g)* Befehl berechnet die Cluster
anhand der **k√ºrzesten Pfade** und einem statistischen Vergleich zwischen
den Clustern. 
-->Walktrap-Algorithmus sucht nach **dichten Teilnetzwerken** im Netzwerk, die sich v.a. durch **kurze Pfaddistanzen** auszeichnen
-->**Merke: Je k√ºrzer die Pfaddistanz, desto enger die Beziehung**

Der Vorteil dieser Methode ist, dass die Ausgabe des Plots
die Cluster gleich farbig zuteilt (diese Zuweisung ist beliebig und kann
nicht ver√§ndert werden). F√ºr die Berechnung werden Teilbeziehungen der
Unternetzwerke zueinander in Verh√§ltnis gesetzt, die Visualisierung
verbindet diese wieder in einer Gesamtdarstellung.

```{r Clusterberechnung Walktrap}
library(igraph)

# Clusterberechnung #erstmal Cluster-Visualisierung
#so k√∂nnen wir einen kurzen √úberblick dar√ºber bekommen, wie unsere Componente aussieht, aus der wir jetzt eine Cluster-Analyse machen wollen
plot(s_comp1, vertex.color="grey80", main="Komponente 1")

# Wie funktioniert der Befehl?
?cluster_walktrap()

# Berechnung der Cluster innerhalb der Komponente
# erstellt die Berechnung f√ºr die Modularit√§t und deren Teilgruppen
cl <- cluster_walktrap(s_comp1) #neues Cluster-Teilnetzwerk zur besseren √úbersicht


#Modularit√§t bedeutet Logischer Skalar, der angibt, ob der Vektor der Modularit√§tswerte in das Ergebnis aufgenommen werden soll. Wenn das Argument membership true ist, wird es immer berechnet.
#Die Modularit√§t des Netzwerks bezeichnet auch die Dichte eines Netzwerks. Je geringer der Modularit√§tswert ist, desto verteilter ist das Netzwerk und desto mehr Komponenten k√∂nnen auftreten
modularity(cl) #0.5257633, also Modularit√§tswert von 52,58 Prozent


#Membership / Zugeh√∂rigkeit bedeutet Zugeh√∂rigkeit	Logischer Skalar, der angibt, ob der Zugeh√∂rigkeitsvektor f√ºr den Split mit dem h√∂chsten Modularit√§tswert berechnet werden soll.
membership(cl) #die in der Console angezeigten Knoten sind Teil des Clusters 

#Wie viele Cluster hat Componente 1?
clusters(s_comp1) #1 gro√üe Componente mit 32 Knoten --> Hauptkomponente
cl #5 Cluster 

#Cluster von Componente 1 plotten
plot(cl, s_comp1,
     edge.arrow.size=.2,
     main="Cluster-Walktrap Analyse von s_comp1")
 



```

####Communities 

F√ºr die Berechnung von *communities* werden automatisch nach dichten
Untergruppen im Netzwerk gesucht. Die Annahme ist, dass eine hohe Dichte
zwischen Knoten f√ºr viel Austausch oder Kontakt steht und dies eine
Gemeinschaft (community) innerhalb des Netzwerks definiert, die sich von
anderen abgrenzen l√§sst.

```{r Communities erstellen}
#Vorbereitung Community-Analyse 

# Anzahl der Componenten
clusters(s) #2 Componenten mit einmal 32 Knoten und einmal 6 Knoten

# Komponenten auftrennen
s_comp <- decompose.graph(s)
s_comp #Komponenten sind jetzt aufgetrennt in eine mit 32 Knoten und 147 Kanten und eine weitere mit 6 Knoten und 29 Kanten (kann man aus der Console ablesen)

# Komponenten neu benennen
s_comp1 <- s_comp[[1]]
s_comp1 #unsere Komponente mit 32 Knoten und 147 Kanten

s_comp2 <- s_comp[[2]]
s_comp2 #unsere Komponente mit 6 Knoten und 29 Kanten

#Eigentliche Community-Analyse 

# Berechnung der Cluster innerhalb der Komponente --> wir betrachten in der Analyse hier nur die Hauptkomponente s_comp1, alle nachfolgenden Befehle gelten analog nat√ºrlich auch f√ºr s_comp2
# erstellt die Berechnung f√ºr die Modularit√§t und deren Teilgruppen
cl <- cluster_walktrap(s_comp1)
cl #5 Gruppen mit je Modularit√§tswert von 53 Prozent
modularity(cl) #Modularit√§tswert von 0.5257633, also von circa 52,58 Prozent
membership(cl) #die in der Konsole angezeigten Knoten geh√∂ren zu diesem Cluster

# Clusterberechnung #Visualisierung der Componente 1
plot(s_comp1,
     edge.arrow.size=.3,
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Komponente 1 (via communities)")

# Berechnung der Cluster innerhalb der Komponente

# Was macht der communities Befehl?
#Die Funktionen zur Erkennung von Graphengemeinschaften geben ihre Ergebnisse als Objekt der Klasse communities zur√ºck. 
#Cluster sind quasi statsistisch relevante Analysen von Communities
?communities()

# Wir verwenden die oben erstellte Aufteilung der Cluster
membership(cl) #die in der Console angezeigten Knoten sind Teil des Clusters

# mit dem Befehl sizes wird die Gr√∂√üe der jeweiligen Communities angezeigt
sizes(cl) #5 Community-Gruppen (obere Zeile in Console sind die Nummern der Communities, untere Zeile sind die Anzahl an Knoten in der jeweilgen Community)
#Community 1: 9 Knoten 
#Community 2: 4 Knoten
#Community 3: 7 Knoten
#Community 4: 8 Knoten
#Community 5: 4 Knoten


# und communities() liefert eine Zuordnung der jeweiligen Knoten auf die Communities
communities(cl) #Unterteilung der verschiedenen Knoten in ihre Communities
#in Konsole wird jetzt ausgegeben, welche Knoten zu welcher Community geh√∂ren

# Achtung: das sind keine igraph-Objekte, sondern nur die Angaben der Knoten. 



```

#####Edge-Betweenness-Cluster

Es gibt noch weitere Clustering-Verfahren, die Cluster nach
unterschiedlichen Kriterien bilden. Der Algorithmus von
*cluster_edge_betweenness()* geht davon aus, dass sich Cluster vor
allem an den "Sollbruchstellen" eines Netzwerks trennen lassen. Diese
werden √ºber den Wert der **Betweenness** berechnet, also die Knoten, die in
hohem Ma√üe f√ºr die Verbindung zu anderen Knoten beitragen.
--> hier werden quasi Untergruppierungen innerhalb des Clusters berechnet

```{r Cluster-Betweeness erstellen}

# Clusterberechnung #Visualisierung
plot(s_comp1, vertex.color="grey80", main="Komponente 1")

# Berechnung der Cluster innerhalb der Komponente
#Viele Netze bestehen aus Modulen, die selbst dicht, aber nur sp√§rlich mit anderen Modulen verbunden sind.
#D.h., Cluster k√∂nnen innerhalb einer Componente entstehen
?cluster_edge_betweenness()

# erstellt die Berechnung f√ºr die Modularit√§t und deren Teilgruppen
eb <- cluster_edge_betweenness(s_comp1)
eb #in Console werden die Angaben zu diesem Cluster angezeigt: es gibt 5 Gruppen, mit einer Modularit√§t von 0.45, also 45 Prozent, au√üerdem werden die Knoten angezeigt, die in den jeweiligen Teilgruppen zu finden sind

#Visualisierung Cluster-Teilgruppen der Componente 1
plot(eb, s_comp1,
     edge.arrow.size=.2,
     main="Edge-Betweenness Cluster")


```


#####Vergleich von Walktrap-Clustern und Edge-Betweenness-Clustern

-->**Cluster-Walktrap**-Analyse: nach **k√ºrzesten Pfaddistanzen**
-->*Cluster-Edge-Betweenness*-Analyse: nach *Betweenness-Werten*

Bei der Analyse
von Clustern ist es notwendig zu verstehen, welche Art von Cluster
berechnet wird.

*Merke*: Das Ergebnis einer Clusteranalyse unterscheidet sich durch die
jeweils eingesetzten Funktionen. Achten Sie deshalb darauf, ob der
entsprechende Algorithmus zu ihrer Forschungfrage passt

```{r Vergleich Walktrap und Edge-Betweeness, fig.height=4, fig.width=6}

# Clusterberechnung #Visualisierung
plot(s_comp1, vertex.color="grey80", main="Komponente 1")

# Berechnung Walktrap-Cluster f√ºr Componente 1
cl <- cluster_walktrap(s_comp1)
cl #5 Gruppen, mit Modularit√§tswert von je 53 Prozent (Angaben in Console ablesbar)

# Berechnung Edge-Betweenness-Cluster f√ºr Componente 1
eb <- cluster_edge_betweenness(s_comp1)
eb #5 Teilgruppen mit einer Modularit√§t von 0.45, also 45 Prozent, in der Console werden die jeweiligen Teilgruppen mit ihren dazugeh√∂rigen Knoten angezeigt

# Visualisierung im Vergleich

par(mfrow=c(1,2), mar=c(0,0,2,1)) 
plot(eb, s_comp1, edge.arrow.size=.2, main="Walktrap-Cluster")
plot(cl, s_comp1, edge.arrow.size=.2, main="Edge-Between-Cluster")
par(mfrow=c(1,1), mar=c(0,0,2,1)) 


```


####Dyaden und Reziprozit√§t 

Dyaden sind wichtige Bausteine f√ºr Netzwerke. Bei **gerichteten Netzwerken**
l√§sst sich hier das Ma√ü der **Reziprozit√§t** berechnen.
--> Reziprozit√§t beschreibt wechselseitige Beziehungen

```{r Dyadenzenus vereinfachtes Gesamtnetzwerk, fig.height=4, fig.width=6, message=FALSE, warning=FALSE, paged.print=TRUE}

# Wir erstellen ein vereinfachtes Gesamtnetzwerk
library(igraph)

#Edgelist einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#(Attribute, die wir f√ºr unsere Analyse nicht brauchen, k√∂nnen wir ggf. auch l√∂schen
#dazu erstellen wir aber ein neues Teilnetzwerk, um den Datensatz unseres urspr√ºnglichen Netzwerkes nicht zu ver√§ndern)
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")

#(wir vereinfachen das Netzwerk zu einer besseren √úbersicht der Verteilung der gewichteten Beziehungen)
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
is_simple(s_sim) #jetzt ist das Netzwerk vereinfacht 

# Durchf√ºhrung des Dyadenzensus
dyad_census(s_sim) 
#27 wechselseitige / reziproke Beziehungen, 70 asymmetrische Beziehungen und 606 gar nicht vorhandene Dyaden
#alles in der Console ablesbar 

# Ausgabe der dyadischen Beziehungen nach dem MAN-Schema
# M = Mutal (reziprok)
# A = Asymmetrical (einseitig gerichtet)
# N = Null (keine Beziehung)

#oder auch

#mut	
#Die Anzahl der Paare mit gegenseitigen Verbindungen.

#asym	
#Die Anzahl der Paare mit nicht-gegenseitigen Verbindungen.

#null	
#Die Anzahl der Paare, zwischen denen keine Verbindung besteht.

# Berechnung der Reziprozit√§t
reciprocity(s_sim, mode="ratio")
# Der berechnete Wert gibt das Verh√§ltnis von reziproken Beziehungen zu normalen Beziehungen an, in diesem Fall sind 27,84% der Beziehungen im Netzwerk reziprok.

# Genauere Analyse der reziproken Beziehungen
# Der Befehl which_mutual gibt genau an, bei welchen Knoten es sich um eine reziproke Beziehung handelt.

?which_mutual

#neues Teilnetzwerk m, um genau zu wissen, welche Knoten eine reziproke Beziehung zueinander haben 

m <- which_mutual(s_sim, eids = E(s_sim))
m

# Wir schreiben jetzt die Werte als Edge-Attribute in die Edgelist
E(s_sim)$reciprocity <- m

#jetzt k√∂nnen wir uns die Reziprozit√§tswerte in der Edgelist anzeigen lassen 
edge.attributes(s_sim)

# Wir m√ºssen jetzt noch die Werte der Edge-Attribute in der Spalte "reciprocity" in logische Operatoren umwandeln:

E(s_sim)$reciprocity  <- as.numeric(E(s_sim)$reciprocity)

#jetzt k√∂nnen wir uns die Reziprozit√§tswerte in der Edgelist besser anzeigen lassen 
edge.attributes(s_sim)$reciprocity
#Codierung in 0 f√ºr keine reziproke Beziehung und 1 f√ºr reziproke Beziehung


# Plot der reziproken Beziehungen zur Veranschaulichung, welcher Knoten mit wem eine reziproke Beziehung hat
plot(s_sim, 
     asp=0,
     layout = layout_with_kk, 
     edge.arror.size=.1,
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     vertex.color="grey80",
     vertex.frame.color=NA,
     edge.width=E(s_sim)$weight/2, 
     edge.color=c("red", "NA")[(E(s_sim)$reciprocity=="0")+1],
     main="vereinfachtes Gesamtnetzwerk", 
     sub="Reziproke Beziehungen in rot"
     )

```


#####Vergleich zweier Teilnetzwerke auf Reziprozit√§t (Dyaden)

**Ergebnisse der Analyse**
Die Analyse zeigt, dass die Beziehungen im Zusammenarbeitsnetzwerk doppelt so h√§ufig reziprok sind, wie die Beziehungen in der Ratsuche. 

```{r Dyadenzensus: Vergleich zweier Netzwerke}

# Anmerkung: Das Beispiel verwendet die zuvor erstellen Teilnetzwerke h_sim und w_sim. Diese Chunks m√ºssen zuvor aktiviert werden.

# Wir wollen herausfinden, ob die Reziprozit√§t bei dem Hilfs- oder Zusammenarbeitsnetzwerk h√∂her ist. Dazu m√ºssen wir mit den zuvor erstellten Teilnetzwerken arbeiten und diese vergleichen. Hierzu passen wir die Skripte aus Kapitel 4a einfach f√ºr die beiden Teilnetzwerke an.

# A Teilnetzwerk help (Ratsuche)

# Durchf√ºhrung des Dyadenzensus
dyad_census(h_sim)

# Ausgabe der dyadischen Beziehungen nach dem MAN-Schema
# M = Mutal (reziprok) #10
# A = Asymmetrical (einseitig gerichtet) #55
# N = Null (keine Beziehung) #638

# Berechnung der Reziprozit√§t
reciprocity(h_sim, mode="ratio")
# Der berechnete Wert gibt das Verh√§ltnis von reziproken Beziehungen zu normalen Beziehungen an, in diesem Fall sind 15,38 % der Beziehungen im Netzwerk reziprok.

# Genauere Analyse der reziproken Beziehungen
# Der Befehl which_mutual gibt genau an, bei welchen Knoten es sich um eine reziproke Beziehung handelt.

mh <- which_mutual(h_sim, eids = E(h_sim))
mh

# Wir schreiben jetzt die Werte als Edge-Attribute in die Edgelist
E(h_sim)$reciprocity <- mh

# Wir m√ºssen jetzt noch die Werte der Edge-Attribute in der Spalte "reciprocity" in logische Operatoren umwandeln:
E(h_sim)$reciprocity  <- as.numeric(E(h_sim)$reciprocity)

#jetzt k√∂nnen wir numerisch codiert sehen, welche Knoten reziproke Beziehungen zueinanader haben und welche nicht
edge.attributes(h_sim)$reciprocity

# B Teilnetzwerk work (Zusammenarbeit)

# Durchf√ºhrung des Dyadenzensus
dyad_census(w_sim)
#18 reziproke
#39 asymmerische, also einseitig gerichtete
#646 keine Beziehungen 

# Berechnung der Reziprozit√§t
reciprocity(w_sim, mode="ratio") #0.3157895, also ca. 31,58 reziproke Beziehungen im Netzwerk

#welche Knoten haben zueinander reziproke Beziehungen
mw <- which_mutual(w_sim, eids = E(w_sim))
mw

# Wir schreiben jetzt die Werte als Edge-Attribute in die Edgelist
E(w_sim)$reciprocity <- mw

#wir wandeln die Reziprozit√§t in numerisch codierte Angabe um
E(w_sim)$reciprocity  <- as.numeric(E(w_sim)$reciprocity)

#jetzt k√∂nnen wir numerisch codiert sehen, welche Knoten reziproke Beziehungen zueinanader haben und welche nicht
edge.attributes(w_sim)$reciprocity

# direkter Vergleich der Reziprozit√§t der beiden Teilnetzwerke visualisieren
par(mfrow=c(1,2), mar=c(0,0,2,0))

plot(h_sim, 
     layout = layout_in_circle, 
     edge.arrow.size=0.4,
     vertex.color=NA,
     edge.width=E(h_sim)$weight, 
     edge.color=c("red", "NA")[(E(h_sim)$reciprocity=="0")+1],
     main="Hilfsnetzwerk (15,38% reziprok)", 
     sub="Reziproke Beziehungen in rot"
     )

plot(w_sim, 
     layout = layout_in_circle, 
     edge.arrow.size=0.4,
     vertex.color=NA,
     edge.width=E(w_sim)$weight, 
     edge.color=c("red", "NA")[(E(w_sim)$reciprocity=="0")+1],
     main="Zusammenarbeitsnetzwerk (31,57% reziprok)", 
     sub="Reziproke Beziehungen in rot"
     )

par(mfrow=c(1,1), mar=c(0,0,2,0))

# Die Analyse zeigt, dass die Beziehungen im Zusammenarbeitsnetzwerk doppelt so h√§ufig reziprok sind, wie die Beziehungen in der Ratsuche. 

```

####Triaden

**Triadenzensus** Der Triadenzensus ist ein etabliertes Instrument, um
die Zusammensetzung von Netzwerken zu analysieren und zu vergleichen.

-->Der Befehl
triad_census(a)
liefert Ihnen folgendes Ergebnis:
 [1] 96785 15350   286   402   741     0     0     0     0     0     0     0     0
[14]     0     0     0
Die 16 ausgegebene Werte bedeuten, dass alle 16 Triaden-Typen im Netzwerk durchsucht wurden. Die **16 Typen** finden Sie √ºber die  Hilfsfunktion **?triad_census()** bzw. in der Tabelle von Fuhse 2018. 
-->**in meiner Fuhse Word-Datei, S. 14**
**Die Werte werden jetzt von links nach rechts gelesen, d.h. nur  die ersten 5 Typen liegen im Netzwerk vor**, es gibt z.B. keine Cliquen (Typ 300 = 0) 
-->Nummer, die da vom Typ steht, gibt an, wie oft der Typ vorkommt

(-->Angabe in der eckigen Klammer in der Konsole zeigt mir, um welchen Triaden-Typ es sich handelt
-->Zahl neben der eckigen Klammer gibt dann an, wie oft dieser Triaden-Typ in der eckigen Klammer vorkommt)

```{r Triadenzensus allgemein}

#  Der Zensus folgt dabei dem abgewandelten M-A-N Schema in der Beschreibung und liefert die Ergebnisse von 16 Triadentypen:

# Die Reihenfolge der Ausgabe l√§sst sich √ºber den Befehl ?triad_census festlegen.
?triad_census #dieser Befehl ist super hilfreich, um kurzen & knappen √úberblick √ºber die Triaden-Typen zu erhalten
# Hier werden 16 Triadentypen numerisch aufsteigend abgetragen.

# √úbersicht √ºber Triaden in einem Netzwerk
triad_census(s_sim)
#3 reziproke Triaden --> also 3 Cliquen im Netzwerk

```

**genauere Analyse von Triaden-Strukturen in einem Netzwerk**

*Unterschied motifs vs. triad_census*
-->**triad_cenus** gibt mir **alle Triaden-Typen** an 
-->w√§hrend **motifs** mir nur die mit **einer bestimmten Anzahl tats√§chlicher Verbindungen** ausspielt, die ich **√ºber size bestimmen** kann 
-->bei motifs in der **Console** immer auf den letzten Wert achten & den dann f√ºr die L√∂sung nehmen -->**der letzte Wert, der ausgegeben wird, zeigt die reziproke Triaden**

*Ergebnisse der Analyse*

In dem Netzwerk s_sim sind 383 triadische Beziehungen angelegt. Achtung:
die Anzahl der Cliquen unterscheidet sich in den Teilnetzwerken!

```{r Triadenstrukturen / Motifs}

# Mit dem Befehl motifs lassen sich spezifische Triadentypen anzeigen:
# Das numerische Argument legt fest, wie viele Verbindungen untersucht werden sollen.

#motifs ist dazu da, gleich aussehende Strukturen zu identifizieren. 
#In unserem Fall geben wir an, dass wir mit der size=3 Strukturen suchen, die aus 3 Verbindungen bestehen. 
#Dementsprechend gibt der Befehl an, wie viele triadische Beziehungen in dem Netzwerk vorkommen. 
#also Unterschied motifs vs. triad_census
#triad_cenus gibt mir alle Triaden-Typen an 
#w√§hrend motifs mir nur die mit einer bestimmten Anzahl tats√§chlicher Verbindungen ausspielt, die ich √ºber size bestimmen kann 
#bei motifs in der Console immer auf den letzten Wert achten & den dann f√ºr die L√∂sung nehmen -->der letzte Wert, der ausgegeben wird, zeigt die reziproke Triaden


motifs(s_sim, size=3) #3

#am besten direkt count_motifs nehemen, das gibt mir dann sofort die Anzahl √ºbersichtlich aus
count_motifs(s_sim, size=3) #383 triadische Beziehungen im Netzwerk

# Die Anzahl der unterschiedlichen motifs entspricht grob dem Triadenzensus.
# Der Gesamtwert gibt alle triadischen Verbindungen in einem Netzwerk an.

```


####Cliquen

Cliquen entsprechen der Triade 300, d.h. einer komplett reziproken
Struktur (A\<-\>B\<-\>C,A\<-\>C).
--> Cliquen bestehen also immer aus mindestens 3 Akteur*innen / Knoten

```{r Kapitel 5c: Triadenstruktur: Cliquen}

# Z√§hlt die Cliquen im Netzwerk
clique_num(s_sim) #5 Cliquen

# listet die Cliquen im Netzwerk auf
lc <- largest_cliques(s_sim)
lc
#2 Cliquen sind mit je 5 Knoten am gr√∂√üten, in der ersten Clique befinden sich die Knoten 20 30 21 18 1 und in der zweiten Clique sind die Knoten 1  18 30 23 21. 

#Befehl alleine aufgelistet w√ºrde auch gehen, aber so wie oben kann man sich das alles problemlos nochmal ausgeben lassen
largest_cliques(s_sim)

#alternativ, aber besser largest_cliques nehmen
maximal.cliques.count(s_sim)

# Umwandlung f√ºr Visualisierung #Name der Knoten anzeigen lassen nur f√ºr Clique 1
V(s_sim)$label <- V(s_sim)$name

#Vorbereitung Visualisierung Clique
s_lc <- subgraph(s_sim, lc[[1]])

#nur Clique 1 visualisiert
plot(s_lc, 
     layout=layout.fruchterman.reingold, 
     vertex.color="gold", 
     edge.arrow.size = 0.5, 
     edge.color = "gray80",
     main = "Gr√∂√üte Clique im CR/PR Netzwerk")


```


##Isolates l√∂schen

In diesem Beispiel wollen wir alle 
**isolierten Knoten** (also Knoten ohne Kante, auch isolates genannt) l√∂schen.
--> der **Degree-Wert von Isolates** betr√§gt immer **0**, da sie ja isoliert sind & somit keine Verbindungen zu anderen Knoten haben

```{r Isolierte Knoten schnell l√∂schen}
# In diesem Beispiel wollen wir alle isolierten Knoten (also Knoten ohne Kante, auch isolates genannt) l√∂schen.

# als Beispiel w√§hlen wir das M√§nnernetzwerk
s_male
vcount(s_male) #6 Knoten
ecount(s_male) #5 Kanten

# ohne isolates
# es werden mit der which() Funktion eine einfache Bedingung gesetzt

s_male_komplett <- delete.vertices(s_male , which(degree(s_male)==0)) #Degree-Wert f√ºr Isolates ist null, das wollen wir l√∂schen

s_male_komplett #4 Knoten und 5 Kanten

#Visualisierung
plot(s_male_komplett,
     vertex.color="lightblue",
     vertex.frame="white",
     main="Netzwerk ohne Isolates")

```

##Ego-Netzwerke (erster Ordnung)

Manchmal ist es hilfreich, bestimmte Knoten aus dem Netzwerk zu
extrahieren, um diese genauer zu untersuchen. Damit "zoomt" man auf
einen Knoten im Netzwerk. Jedes Netzwerk besteht aus **Egos (einzelne Knoten)** und deren **Alteri (andere Knoten, die mit dem zu analysierenden Ego verbunden sind)**. 
Diese Ego-Netzwerke lassen sich auch einzeln
analyisieren. Wir verwenden daf√ºr die Befehle ego_size() und
make_ego_graph().

Uns interessiert, wer im Netzwerk s_sim die meisten Beziehungen hat und
dessen direktes Netzwerk. Deshalb selektieren wir zun√§chst den Knoten
mit dem h√∂chsten degree-Wert und erstellen danach das Ego-Netzwerk.

```{r Ego-Netzwerk f√ºr den h√∂chsten Degree erstellen}
# Achtung: beim Erstellen der Ego-Netzwerke ist es sinnvoll, das zugrundeliegende Netzwerk neu einzulesen, damit R eine saubere Indizierung vornehmen kann.

#Vorbereitung f√ºr Ego-Netzwerk-Analyse

# Wir erstellen ein vereinfachtes Gesamtnetzwerk
library(igraph)

#Edgelist einlesen 
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgemtrix erstellen
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Um das Netzwerk zu vereinfachen, kann man Attribute l√∂schen, die man f√ºr die Analyse nicht braucht
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")

#Vereinfachung des Netzwerks
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))

#Ego-Netzwerk-Analyse

# zeigt die Knoten mit den meisten Verbindungen, √§hnlich wie der degree Wert.
ego_size(s_sim)
which.max(ego_size(s_sim)) #18 ist der Knoten mit den meisten Verbindungen / dem h√∂chsten Degree-Wert

which.min(ego_size(s_sim)) # Knoten 22 hat die wenigsten Verbindungen / den niedrigsten Degree-Wert 

# Wir stellen fest, dass Knoten 18 die meisten degrees hat. Deshalb wollen wir ein Ego-Netzwerk aus diesem Graph generieren.
degree(s_sim) #zeigt in der Konsole die Degree-Werte an: obere Zeile sind die Knotennummern, untere Zeile ihre jeweiligen Degree-Werte 

which.max(degree(s_sim)) #Knoten 18 mit einem Degree-Wert von 18 

# selektiert aus dem Netzwerk h3 alle Knoten, die mit Knoten 18 √ºber einen Schritt verbunden sind.
#es handelt sich hierbei um ein Ego-Netzwerk ersten Grades, zu erkennen an der Zahl hinter dem = bei order
king <- make_ego_graph(s_sim, order = 1, nodes = V(s_sim)$name == 18, mode ="all")

# man braucht diesen Zwischenschrit, damit das igraph-Objekt von king1 hergestellt ist
#Ego-Netzwerk erster Ordnung 
king1 <- king[[1]]
king1 #15 Knoten, 46 Beziehungen --> Anzahl der Knoten ergibt dann, wie viele Alteri es sind, die Ego hat & wie viele Beziehungen Ego zu Alteri hat

plot(king1, 
     main="Ego-Netzwerk Knoten 18, erster Grad",
     vertex.color="gold",
     vertex.frame.color=NA,
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="nur direkte Beziehungen des ersten Grads (15 alteri)")

```

#####Ego-Netzwerke zweiter & dritter Ordnung 

Ego-Netzwerke lassen sich
leicht um die zweite oder dritte Ordnung erweitern. Dies erm√∂glicht eine
genauere Analyse 
--> **erste Ordnung**: nur Beziehung **Ego zu Alteri** 
--> **zweite Ordnung**: Beziehung **Alteri zu weiteren Alteri** miteinbezogen (quasi **erweitert um deren Beziehungen zu deren Kontakten**)
--> **dritte Ordnung**: Beziehung von **Ego zu Alteri, Alteri zu deren Kontakten, Kontakte Alteri zu wiederrum deren Kontakten**

```{r Egonetzwerk zweiter Ordnung}

#Ego-Netzwerk zweiter Odnung f√ºr Knoten 18
king2 <- make_ego_graph(s_sim, order = 2, nodes = V(s_sim)$name == 18, mode ="all")

#notwendiger Zwischenschritt vor dem Plotten
king2 <- king2[[1]]
king2 #27 Knoten, also 27 Alteri und 93 Beziehungen 

plot(king2, 
     main="Ego-Netzwerk Knoten 18, 2. Grad",
     vertex.color="orange",
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="Beziehungen des zweiten Grads (27 alteri)")


#Ego-Netzwerk dritten Grades von Knoten 18
king3 <- make_ego_graph(s_sim, order = 3, nodes = V(s_sim)$name == 18, mode ="all")

#notwendiger Zwischenschritt vor der Visualisierung
king3 <- king3[[1]]
king3 #32 Alteri und 112 Beziehungen 

plot(king3, 
     main="Ego-Netzwerk Knoten 18, 3. Grad",
     vertex.color="red",
     edge.color="grey80",
     edge.arrow.size=.3,
     sub="Beziehungen des dritten Grads, 32 alteri")

# erst durch die Einbeziehung der Beziehungen des zweiten Grads wird die Beziehungsstruktur innerhalb des Netzwerks sichtbar. 

# Darstellung als Vergleich:

par(mfrow=c(1,3), mar=c(0,0,1,2))
plot(king1, edge.arrow.size=.3, main="Erster Grad")
plot(king2, edge.arrow.size=.3,  main="Zweiter Grad")
plot(king3, edge.arrow.size=.3, main="Dritter Grad")

par(mfrow=c(1,1), mar=c(0,0,1,2))

```

#Netzwerkma√üe

##Zentralit√§tsma√üe

Je nach Auswahl des Netzwerks unterscheiden sich die Analyseergebnisse
stark. Deshalb ist es notwendig, zun√§chst zu kl√§ren, welche Netzwerke
untersucht werden sollen.

Damit die Daten konsistent bleiben, werden hier das vereinfachte
Gesamtnetzwerk sowie die vereinfachten Unternetzwerke erneut erstellt.
Das ist in der Regel nicht notwendig, dient hier aber der Absicherung
der Datenkonsistenz.

**Vorbereitung**

```{r Zentralit√§tsma√üe: vereinfachte Netzwerke, message=FALSE, warning=FALSE, paged.print=FALSE}

# Netzwerk einlesen und vereinfachen f√ºr Analyse

library(igraph)

#Edgelist einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodlist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#um das Netzwerk zu vereinfachen, k√∂nnen wir Attribute l√∂schen, die wir nicht f√ºr die Analyse brauchen
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")

#Netzwerk vereinfachen
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))

#Netzwerk ist jetzt vereinfacht
is_simple(s_sim)

# Teilnetzwerke

#Teilnetzwerk Zusammenarbeit erstellen --> die Beziehung der Zusammenarbeit ist mit 1 codiert, darum m√ºssen wir das beim Attribut relation ausw√§hlen
work <- subgraph.edges(s, E(s)[relation==1]) 

#Teilnetzwerk Ratsuche erstellen --> die Beziehung der Ratsuche ist mit 2 codiert, darum m√ºssen wir das beim Attribut relation ausw√§hlen
help <- subgraph.edges(s, E(s)[relation==2])

#Teilnetzwerk Beziehung erstellen --> die Beziehung ist mit 3 codiert, darum m√ºssen wir das beim Attribut relation ausw√§hlen
love <- subgraph.edges(s, E(s)[relation==3])

#Attribute l√∂schen, die wir f√ºr die Analyse nicht unbedingt brauchen
work <- delete_edge_attr(work, "relation")
work <- delete_edge_attr(work, "complicated")

help <- delete_edge_attr(help, "relation")
help <- delete_edge_attr(help, "complicated")

love <- delete_edge_attr(love, "relation")

#Vereinfachung 

#Netzwerk Zusammenarbeit
w_sim <- simplify(work,edge.attr.comb=list(weight="sum"))
is_simple(w_sim)

#Netzwerk Ratsuche
h_sim <- simplify(help,edge.attr.comb=list(weight="sum"))
is_simple(h_sim)


```


##Degrees

**Degree-Werte allgemein** 
*Indegree* --> Beziehungen zu dem Knoten hin 
*Outdegree* --> Beziehungen von dem Knoten ausgehend zu Alteri 


**Analyse des Knotens mit den h√§ufigsten starken Beziehungen**

Der Vergleich der Netzwerke zeigt: - f√ºr das Gesamtnetzwerk: Knoten 18
mit einem Degree-Wert von 18 - im vereinfachten Gesamtnetzwerk: Knoten
18 mit einem Degree-Wert von 18 - Teilnetzwerk Work (vereinfacht):
Knoten 19 mit einem Degree-Wert von 11 - Teilnetzwerk Help
(verereinfacht): Knoten 18 mit einem Degree-Wert von 18


```{r Zentralit√§t: Degree-Werte allgemein}

# 1. Knoten mit den st√§rksten Beziehungen im Gesamtnetzwerk
degree(s, mode="all") #Degree Werte f√ºr alle Knoten im Gesamtnetzwerk
#obere Zeile in Konsole: Knotennummern
#untere Spalte in Konsole: die jweiligen Degree-Werte der Knoten

#Knoten mit gr√∂√ütem Degree-Wert im Netzwerk ermitteln
which.max(degree(s, mode="all")) #Knoten 18 hat mit 18 den h√∂chsten Degree-Wert im Netzwerk und damit die meisten Beziehungen zu den anderen Knoten / zu den alteri

# 2. Vergleich mit dem vereinfachten Netzwerk
# Vergleich mit dem einfachen simplified Netzwerk
degree(s_sim, mode="all")
which.max(degree(s_sim, mode="all")) #Knoten 18 hat den h√∂chsten Degree-Wert im Netzwerk und damit die meisten Beziehungen zu den anderen Knoten / zu den alteri

# neues vertex-Attribut erstellen f√ºr bessere √úbersicht
V(s_sim)$degree<-degree(s_sim)
list.vertex.attributes(s_sim) #jetzt Degree als Vertex-Attribut aufgenommen
vertex.attributes(s_sim)$degree #zeigt alle Degree-Werte f√ºr das Netzwerk s_sim in Konsole an 

#alternativ: exakten Degree-Wert von Knoten 18 berechnen
degree_of_node_18 <- degree(s_sim, 18)
degree_of_node_18 #18 --> also 18 Beziehungen zu alteri


# 3. Teilnetzwerke 
# 3.1 Zusammenarbeit
degree(w_sim, mode="all")
which.max(degree(w_sim, mode="all")) #die anderen Akteur*innen arbeiten am meisten mit Knoten 19 zusammen

#exakten Degree-Wert von Knoten 19 berechnen
degree_of_node_19 <- degree(s_sim, 19)
degree_of_node_19 #11 Beziehungen zu alteri

# 3.2 Ratsuche
degree(h_sim, mode="all")
which.max(degree(h_sim, mode="all")) #Knoten 18 wird am meisten um Rat gefragt

degree_of_node_18 <- degree(s_sim, 18)
degree_of_node_18 #18 --> also 18 Beziehungen zu alteri

```

###normalisierte Degree-Werte 

**Anmerkung**

Die absoluten Zahlen sind allerdings nur begrenzt aussagekr√§ftig:
Deshalb l√§sst sich der Degree-Wert leicht normalisieren, d.h. als
Prozentwert darstellen. Deshalb werden wir folgend nur noch mit den
prozentualen Werten arbeiten. Diese Methode nennt sich **Normalisierung**
und berechnet den **Degree-Wert eines Knotens im Verh√§ltnis zu allen anderen Knoten**. Damit erreicht man eine genauere Aussage als mit einem
reinen numerischen Wert. Daf√ºr wird der Befehl um das Argument
normalized = TRUE erg√§nzt.

**Ergebnisse der Analyse**

Der Vergleich der Netzwerke zeigt:

\- f√ºr das Gesamtnetzwerk: Knoten 18 hat 56,76% aller Degree-Werte.\
- im vereinfachten Gesamtnetzwerk: Knoten 18 hat 48,65% aller
Degree-Werte. - Teilnetzwerk Work (vereinfacht): Knoten 19 hat 21,62%
aller Degree-Werte. - Teilnetzwerk Help (verereinfacht): Knoten 18 mit
40,54% aller Degree-Werte.

Mit den normalisierten, d.h. ins Verh√§ltnis gesetzten Zahlen lassen sich
viel genauere Aussagen √ºber die positionalen Ma√üe treffen.

```{r Zentralit√§t: Degree-Werte zentralisiert}

# 1. Knoten mit den st√§rksten Beziehungen im Gesamtnetzwerk
degree(s, mode="all", normalized = TRUE) #Knoten mit den jeweiligen Degree-Werten (in Console die Werte unter dem jeweiligen Knoten)

#Knoten mit den meisten Degrees ermitteln
which.max(degree(s, mode="all")) #Knoten 18 hat die meisten Degrees und damit die meisten Beziehungen

degree(s, mode="all", normalized = TRUE)

#0.5675676 Degree-Wert von Knoten 18, also 56,76 aller Beziehungen im Netzwerk s hat Knoten 18


# 2. Vergleich mit dem vereinfachten Netzwerk
# Vergleich mit dem einfachen simplified Netzwerk
degree(s_sim, mode="all", normalized = TRUE) #Knoten mit den jeweiligen Degree-Werten (in Console die Werte unter dem jeweiligen Knoten)

#Knoten mit den meisten Degrees ermitteln
which.max(degree(s_sim, mode="all")) #Knoten 18 hat die meisten Degrees und damit die meisten Beziehungen

degree(s_sim, mode="all", normalized = TRUE)

#0.48648649 Degree-Wert, also 48,65 Prozent aller Beziehungen im Netzwerk s_sim hat Knoten 18

# 3. Teilnetzwerke 
# 3.1 Zusammenarbeit

degree(w_sim, mode="all", normalized = TRUE) #Knoten mit den jeweiligen Degree-Werten (in Console die Werte unter dem jeweiligen Knoten)

#Knoten mit den meisten Degrees ermitteln
which.max(degree(w_sim, mode="all")) #Knoten 19 hat die meisten Beziehungen

degree(w_sim, mode="all", normalized = TRUE)

#0.21621622 Degree-Wert, also 21,62 Prozent aller Beziehungen im Netzwerk w_sim hat Knoten 19

# 3.2 Ratsuche
degree(h_sim, mode="all", normalized = TRUE) #Knoten mit den jeweiligen Degree-Werten (in Console die Werte unter dem jeweiligen Knoten)

#Knoten mit den meisten Degrees ermitteln
which.max(degree(h_sim, mode="all")) 

degree(h_sim, mode="all", normalized = TRUE) 

#Knoten 18 hat die meisten Beziehungen und einen Degree-Wert von 0.40540541, also 40,54 Prozent aller Beziehungen im Netzwerk h_sim  hat Knoten 18

```

####Indegree als Popularit√§tsma√ü vs. Outdegree 

Das Zentralit√§tsma√ü Indegree wird h√§ufig als Popularit√§tsma√ü
interpretiert.
--> Indegree: Beziehungen Alteri zu Ego hin

**Ergebnis der Analyse**

**Wer ist besonders beliebt im Netzwerk?** Das Zentralit√§tsma√ü
"indegree" liefert eine Auskunft dar√ºber, wer in einem Netzwerk
besonders popul√§r ist. Betrachtet werden die

-   *Gesamtnetzwerk*: Knoten 18 scheint im Gesamtnetzwerk mit einem Wert
    35,13% der beliebteste Knoten zu sein.

-   *Zusammenarbeit*: Knoten 19 ist am beliebtesten bei der
    Zusammenarbeit: 16,21% aller Indegrees entfallen auf diesen Knoten.

-   *Unterst√ºtzung*: Knoten 18 vereint 35,13% aller Ratsuchenden auf
    sich.

-   *Liebesbeziehung*: Knoten 23 hat den mit 22,72% ein hohes Ma√ü an
    Popularit√§t.

```{r Zentralit√§t: Indegree als Popularit√§tsma√ü}

# Gesamtnetzwerk (vereinfacht)

#Indegrees

# zeigt die normalisierte Indegree-Verteilung im vereinfachten Gesamtnetzwerk, also den prozentualen Indegree-Wert

degree(s_sim, mode="in", normalized = TRUE) #in der Console werden jetzt die verschiedenen Knoten mit ihren Indegree-Werten angezeigt

# liefert den Knoten mit der h√∂chsten Anzahl von starken Beziehungen
which.max(degree(s_sim, mode="in")) 

degree(s_sim, mode="in", normalized = TRUE)
#Knoten 18 hat den h√∂chsten Indegree-Wert mit 0.35135135, also die meisten Beziehungen im Netzwerk von den Alteri aus zu dem Knoten hin, also gehen 35,13 Prozent aller Beziehungen im Gesamtnetzwerk zu Knoten 18

# 1. Work-Netzwerk: 
# zeigt die einfache Zentralit√§t im Netzwerk der st√§rksten Beziehungen an, also die prozentualen Indegree-Werte
degree(w_sim, mode="in", normalized = TRUE) #in der Console werden jetzt die verschiedenen Knoten mit ihren Indegree-Werten angezeigt


# liefert den Knoten mit der h√∂chsten Anzahl von starken Beziehungen
which.max(degree(w_sim, mode="in")) 
degree(w_sim, mode="in", normalized = TRUE)
#Knoten 19 hat den h√∂chsten Indegree-Wert mit 0.16216216, also die meisten Beziehungen im Netzwerk von den Alteri aus zu dem Knoten hin, also gehen 16,21 Prozent der Beziehungen im Zusammenarbeitsnetzwerk zu Knoten 19

# 2. Help-Netzwerk
degree(h_sim, mode="in", normalized = TRUE)

which.max(degree(h_sim, mode="in")) 
degree(h_sim, mode="in", normalized = TRUE)
#Knoten 18 hat den h√∂chsten Indegree-Wert mit 0.35135135, also 35,13 Prozent der Beziehungen im Ratsuche Netzwerk sind zu Knoten 18.

# 3. Love-Netzwerk
degree(love, mode="in", normalized = TRUE)
which.max(degree(love, mode="in"))
degree(love, mode="in", normalized = TRUE)
#Knoten 23 hat den h√∂chsten Indegree-Wert mit 0.22727273, also gehen 22,72 Prozent der Beziehungen im Liebes-Netzwerk zu Knoten 23

#funktioniert genauso auch mit dem Befehl which.min f√ºr den niedrigsten Wert 

#Outdegrees

# zeigt die normalisierte Indegree-Verteilung im vereinfachten Gesamtnetzwerk, also den prozentualen Outdegree-Wert

degree(s_sim, mode="out", normalized = TRUE) #in der Console werden jetzt die verschiedenen Knoten mit ihren Outdegree-Werten angezeigt

# liefert den Knoten mit der h√∂chsten Anzahl von starken Beziehungen
which.max(degree(s_sim, mode="out")) #Knoten 1

degree(s_sim, mode="out", normalized = TRUE)
#Knoten 1 hat den h√∂chsten Outdegree-Wert mit 0.13513514, also die meisten Beziehungen im Netzwerk zu Alteri hin, also gehen 13,51 Prozent aller Beziehungen im Gesamtnetzwerk von Knoten 1 aus

# 1. Work-Netzwerk: 
# zeigt die einfache Zentralit√§t im Netzwerk der st√§rksten Beziehungen an, also die prozentualen Outdegree-Werte
degree(w_sim, mode="out", normalized = TRUE) #in der Console werden jetzt die verschiedenen Knoten mit ihren Indegree-Werten angezeigt


# liefert den Knoten mit der h√∂chsten Anzahl von starken Beziehungen
which.max(degree(w_sim, mode="out")) #1
degree(w_sim, mode="out", normalized = TRUE)
#Knoten 1 hat den h√∂chsten Outdegree-Wert mit 0.05405405, also die meisten Beziehungen im Netzwerk zu Alteri hin, also gehen 5,41 Prozent aller Beziehungen im Gesamtnetzwerk von Knoten 1 aus

# 2. Help-Netzwerk
degree(h_sim, mode="out", normalized = TRUE)

which.max(degree(h_sim, mode="out")) #1
degree(h_sim, mode="out", normalized = TRUE)
#Knoten 1 hat den h√∂chsten Outdegree-Wert mit 0.05405405, also die meisten Beziehungen im Netzwerk zu Alteri hin, also gehen 5,41 Prozent aller Beziehungen im Gesamtnetzwerk von Knoten 1 aus

# 3. Love-Netzwerk
degree(love, mode="out", normalized = TRUE)
which.max(degree(love, mode="out")) #28
degree(love, mode="out", normalized = TRUE)
#Knoten 1 hat den h√∂chsten Outdegree-Wert mit 0.09090909, also die meisten Beziehungen im Netzwerk zu Alteri hin, also gehen 9,1 Prozent aller Beziehungen im Gesamtnetzwerk von Knoten 1 aus


#funktioniert genauso auch mit dem Befehl which.min f√ºr den niedrigsten Wert 

```


#### Degree Werte analysieren und nach Top-Werten sortieren

```{r Degree Werte auslesen}

# Liste der Attribute anzeigen lassen
list.vertex.attributes(work)

# Degree-Werte berechnen und als Attribute anlegen

#Indegree
ind <- degree(work, mode="in")


#Outdegree
outd <- degree(work, mode="out")

#alle Degree-Werte f√ºr das Teilnetzwerk Zusammenarbeit
degree <- degree(work)
degree

# Vertex-Attribute in Liste anlegen

#alle Degree-Werte f√ºr das Teilnetzwerk Zusammenarbeit
V(work)$degree <- degree

#Indegree
V(work)$degree_in <- ind

#Outdegree
V(work)$degree_out <- outd

# Liste der Attribute anzeigen lassen
list.vertex.attributes(work) #jetzt sind Degree-Werte in Nodelist aufgenommen

# Knoten mit den h√∂chsten Degree-Wert anzeigen
which.max(V(work)$degree) #Knoten 19 h√∂chster Degree-Wert insgesamt
which.max(V(work)$degree_out) #Knoten 1 h√∂chster Outdegree

# Problem: wie sieht man nicht nur den einen h√∂chsten Wert?
# L√∂sung: Nodelist exportieren, dann normal behandeln wie Datensatz

# erstellt data.frames (Tabellen) aus dem igraph Objekt
work_nodelist <- as_data_frame(work, "vertices" )
work_edgelist <- as_data_frame(work, "edges" )

# df aufrufen
work_nodelist
work_edgelist

# Die Tabellen k√∂nnen jetzt ganz normal mit tidyverse oder dyplr weiterverwendet werden

library(tidyverse)
work_nodelist

# Die Top3 Degrees
work_nodelist |> 
  select(name, name_first, degree) |> 
  slice_max(degree, n=3)

#Andrea h√∂chster Degree von 8
#Dana zweith√∂chster Degree von 7 
#Zuleika auch zweith√∂chster Degree von 7

#alternativ:
# h√∂chster Outdegree
which.max(degree(work, mode="out"))

# h√∂chster Indegree
which.max(degree(work, mode="in"))



```


### Betweeness und Broker im Netzwerk

Der Zentralit√§tswert "Betweenness" zeigt, wie relevant einzelne Knoten
f√ºr die **Vernetzung zu anderen Knoten** sind. Es geht also um **Br√ºcken** oder
**Broker**, die zwischen den einzelnen Netzwerken verbinden k√∂nnen.
--> **Broker quasi Verbindungsakteur*in in einem Netzwerk**
--> kann innerhalb eines Netzwerks sein oder zwischen verschiedenen Teilnetzwerken / Componenten / Communities / Clustern 

```{r Zentralit√§t: Betweenness als Broker, fig.height=4, fig.width=6, message=FALSE, warning=FALSE, paged.print=FALSE}

# Gesamtnetzwerk (vereinfacht)
# zeigt die normalisierte Betweenness-Verteilung im vereinfachten Gesamtnetzwerk, also die prozentualen Werte f√ºr die Betweenness
betweenness(s_sim) #in der Console werden die einzelnen Knoten mit ihrem Betweenness-Wert angezeigt

# liefert den Knoten mit der h√∂chsten Anzahl von starken Beziehungen, also derjenige Knoten, der andere Knoten miteinander vernetzt 
which.max(betweenness(s_sim)) #18
betweenness(s_sim)

#Knoten 38 hat Betweenness-Wert von 0.217592593, also verbindet Knoten 18 21,76 Prozent der anderen Knoten miteinander im vereinfachen Gesamtnetzwerk und ist somit der Broker  

# 1. Work-Netzwerk: 
# zeigt die einfache Zentralit√§t im Netzwerk der st√§rksten Beziehungen an, also die prozentualen Werte f√ºr die Betweenness
betweenness(w_sim)

# liefert den Knoten mit der h√∂chsten Anzahl von starken Beziehungen, also derjenige Knoten, der andere Knoten miteinander vernetzt 
which.max(betweenness(w_sim)) #19
betweenness(w_sim)
#Knoten 19 hat einen Betweenness-Wert von 0.105855856, also verbindet Knoten 19 10,59 Prozent der anderen Knoten im Zusammenarbeitsnetzwerk miteinander und ist der Broker im Netzwerk

# 2. Help-Netzwerk
betweenness(h_sim)
which.max(betweenness(h_sim)) 
betweenness(h_sim)
#Knoten 18 hat den h√∂chsten Betweenness-Wert mit 0.1257507508, also verbindet Knoten 18 12,58 Prozent der anderen Knoten im Ratsuchenetzwerk und ist somit der Broker im Netzwerk

# 3. Love-Netzwerk
betweenness(love)
which.max(betweenness(love)) 
betweenness(love)
#Knoten 23 hat den h√∂chsten Betweenness-Wert mit 0.012987013, also verbindet Knoten 23 1,299 Prozent der anderen Knoten im Liebesnetzwerk und ist somit der Broker im Netzwerk

# weist dem Broker im vereinfachten Gesamtnetzwerk eine Farbe zu
V(s_sim)[V(s_sim)$name == 18]$frame.color <- "red"

plot(s_sim, 
     asp=0,
     layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="grey80",
     vertex.color="gold",
     vertex.size=6,
     # vertex.frame.color=NA,
     # vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     main="Broker im Netzwerk",
     sub="vereinfachtes Hauptnetzwerk")

```


### Closeness

**Closeness** ist ein Zentralit√§tma√ü, das berechnet, welche Knoten **eng miteinander verbunden** sind. Allerdings kann das Zentralit√§tsma√ü **nur bei Netzwerken eingesetzt werden, die nicht √ºber mehrere Komponenten verf√ºgen**. Deshalb analysieren wir in diesem Beispiel nur die **Hauptkomponente** des vereinfachten Netzwerks und erstellen diese zun√§chst neu.
**Closness** berechnet die **relative N√§he zu anderen Knoten**. Damit l√§sst sich interpretieren, welche Knoten im Netzwerk eine zentrale Rolle haben.

**Ergebnisse der Analyse**

In der Hauptkomponente hat Knoten 32 mit einem Wert von 38,75% die
h√∂chste Closness-Zentralit√§t, die niedrigste hat Knoten 28 mit 14,29%.

```{r Zentralit√§t: Closeness, fig.height=4, fig.width=6, message=FALSE, warning=FALSE, paged.print=FALSE}

# Closeness 
??closness

# Closeness ist ein Zentralit√§tma√ü, das berechnet, welche Knoten eng miteinander verbunden sind. Allerdings kann das Zentralit√§tsma√ü nur bei Netzwerken eingesetzt werden, die nicht √ºber mehrere Komponenten verf√ºgen. Deshalb analysieren wir in diesem Beispiel nur die Hauptkomponente des vereinfachten Netzwerks und erstellen diese zun√§chst neu.

# Netzwerk neu einlesen und Komponenten isolieren
library(igraph)

#Edgelsit einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# (Vereinfachtes Hauptnetzwerk
#Wir k√∂nnen diejenigen Attribute l√∂schen, die wir f√ºr unsere Analyse nicht brauchen)
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")

#vereinfachtes Netzwerk
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))

# Komponenten auftrennen, da sich die Closeness ja nur f√ºr eine Komponente ermitteln l√§sst
s_comp <- decompose.graph(s_sim)
s_comp #jetzt haben wir das Netzwerk in 2 Componenten aufgeteilt: Componente 1 mit 32 Knoten und 112 Kanten + Komponente 2 mit 6 Knoten und 12 Kanten

# Komponenten neu benennen
s_comp1 <- s_comp[[1]] #Komponente 1 mit 32 Knoten und 112 Kanten
s_comp2 <- s_comp[[2]] #Komponente 2 mit 6 Knoten und 12 Kanten

# neue Teilkomponenten analysieren
s_comp1 #Komponente 1 hat 32 Knoten und 112 Kanten
s_comp2 #Komponente 2 hat 6 Knoten und 12 Kanten
#kann man auch mit vcount und ecount machen 
 
 
# Closeness
# Closness berechnet die relative, also prozentuale N√§he zu anderen Knoten. Damit l√§sst sich interpretieren, welche Knoten im Netzwerk eine zentrale Rolle haben.

#Closeness f√ºr Komponente 1 berechnen
close <- closeness(s_comp1, mode="all", normalized=TRUE)

# liefert den Knoten mit der h√∂chsten Anzahl von starken Beziehungen
close #Knoten der Componente 1 mit ihren jeweiligen Closeness-Werten werden in der Console angezeigt

#Welcher Knoten ist relativ am n√§chsten zu anderen Knoten?
which.max(close) #32
close 
#Knoten 32 ist am n√§chsten zu den anderen Knoten mit einem Closeness-Wert von 0.3875000, also einer relativen Closeness von 38,75 Prozent.

#Welcher Knoten ist relativ am weitesten entfernt zu anderen Knoten?
which.min(close) #Knoten 28 ist mit einem Closeness-Wert von 0.1428571, also einer relativen Closeness von 14,29 Prozent am weitesten weg von den anderen Knoten 

# weist den gr√∂√üten und kleinsten Werten eine Randfarbe zu
V(s_comp1)[V(s_comp1)$name == 32]$frame.color <- "red"
V(s_comp1)[V(s_comp1)$name == 28]$frame.color <- "green"

plot(s_comp1, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="gold",
     vertex.color="gold",
     # vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Hauptkomponente",
     sub="Closeness-Werte illustriert")
     

```

### Spezialfall: InfluenceR (nice2have)

Wenn es um einflussreiche Knoten in einem Netzwerk geht, gibt es ein
Spezialpaket InfluenceR, das zus√§tzlich installiert werden kann. Damit
wird es sehr einfach, einflussreiche Knoten auszulesen. Allerdings
funktioniert das Paket nur bei ungerichteten Knoten, deshalb werden wir
das Netzwerk neu erstellen.

**Ergebnisse der Analyse**

Mit der Programmbibliothek InfluenceR lie√üen sich zwei weitere relevante
Knoten isolieren, die f√ºr die Konfiguration des Netzwerks (im Falle
eines ungerichteten Netzwerks) relevant sind: Knoten 18 erm√∂glicht es,
sogenannte strukturelle L√∂cher im Netzwerk anzusprechen w√§hrend Knoten 5
eine Br√ºckenfunktion √ºbernimmt.

```{r InfluencerR Paket: Analyse von einflussreichen Knoten, fig.height=4, fig.width=6, message=FALSE, warning=FALSE, paged.print=FALSE}

# Installation InfluenceR Programmbibliothek (nur, falls n√∂tig)
# install.packages("influenceR")

library(igraph)
library(influenceR)

# Einlesen des Netzwerks als ungerichtetes Netzwerk und entsprechende Vereinfachung

library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=FALSE)
# Vereinfachtes Hauptnetzwerk
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
ssu <- simplify(ss,edge.attr.comb=list(weight="sum"))
# neues ungerichtetes simplifiziertes Netzwerk f√ºr InfluenceR Analyse
ssu

# Was macht die Programmbibliothek InfluenceR?
??influenceR

# Wir erhalten einige neue Funktionen hinzu:
# 1. ens(g) berechnet den Zugang zu strukturellen L√∂chern in einem Netzwerk

holes <- ens(ssu)
which.max(holes) # Knoten 18 hat den gr√∂√üten Zugang zu strukturellen L√∂cher 

# 2. bridging(g) berechnet die Knoten, die es erm√∂glichen, schneller andere Knoten zu erreichen, sogenannte Br√ºcken. (nach Valente)

bridges <- bridging(ssu)
which.max(bridges) #Knoten 5 erm√∂glicht es, schneller andere Knoten zu erreichen und ist damit eine Br√ºcke innerhalb des Netzwerkes 

# weist den gr√∂√üten und kleinsten Werten eine Randfarbe zu
#Zuweisung Farbe f√ºr Zugang zu strukturellen L√∂chern
V(ssu)[V(ssu)$name == 18]$color <- "green"

#Zuweisung Farbe f√ºr Br√ºcken
V(ssu)[V(ssu)$name == 5]$color <- "blue"

plot(ssu, layout=layout_nicely,
		 asp=0,
     edge.arrow.size=.4,
     edge.color="gold",
		 vertex.size=10,
     # vertex.color="gold",
		 vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Einflussreiche Knoten",
     sub="Strukturelle L√∂cher (gr√ºn) und Br√ºcken (blau)")

```

# Netzwerktheorie

## Erkl√§rungsmuster: Reziprozit√§t, Transitivit√§t, Homophilie

F√ºr die Struktur von Netzwerken liegen einige Erkl√§rungsmuster vor, dazu
geh√∂ren **Reziprozit√§t**, **Transitivit√§t** und **Homophilie**.

**Reziprozit√§t** ist die gegenseitige Anerkennung in Netzwerken, d.h. dass
Knoten (in gerichteten Netzwerken) gegenseitig gegenseitig verbunden
sind. 
--> wechselseitige Beziehungen 

**Transitivit√§t** beschreibt die M√∂glichkeit, dass zwischen Knoten
eine Weitergabe stattfindet
--> Streben nach ausgeglichenen Beziehungen 
--> wenn A und B jeweils mit C befreundet sind, ist die Wkeit hoch, dass A und B sich auch miteinander anfreunden 

**Homophilie** betont die √Ñhnlichkeit von
Knoten.
--> gleich und gleich gesellt sich gern
--> Werte-Homophilie / Einstellungshomophilie: √Ñhnlichkeit in Werten und Weltanschauungen


**Veranschaulichung** **Vorbereitung**

```{r Theorie: Netzwerk erstellen}

library(igraph)

#Edgelist einlesen 
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen 
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt 
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Teilnetzwerk Zusammenarbeit
work <- subgraph.edges(s, E(s)[relation==1]) 

#Teilnetzwerk Ratsuche 
help <- subgraph.edges(s, E(s)[relation==2])

# Da es uns um Erkl√§rungsmuster geht, werden die Nezwerke nicht vereinfacht

```


### Reziprozit√§t

F√ºr die Berechnung der Reziprozit√§t vergleichen wir die Teilnetzwerke

**Reziprozit√§t** ist die gegenseitige Anerkennung in Netzwerken, d.h. dass
Knoten (in gerichteten Netzwerken) gegenseitig gegenseitig verbunden
sind. 
--> wechselseitige Beziehungen 

**Ergebnisse der Analyse**

Der Wert der Reziprozit√§t l√§sst sich nur im Verh√§ltnis zu anderen Werten
erkl√§ren. Das Netzwerk der **Zusammenarbeit** hat die h√∂chste
ausgepr√§gte Reziprozit√§t von 47,37%. Das ist naheliegend, da die Wahl
der Teams h√§ufig durch gegenseitige Sympathie bzw. vorherige Erfahrungen
gepr√§gt sind. Hingegen ist die **Ratsuche** deutlich einseitiger
ausgepr√§gt mit 26,32% von reziproken Beziehungen. Auch dies erscheint
aufgrund der Fragestellung naheliegend zu sein, denn die Ratsuche
verl√§uft in den wenigsten F√§llen tats√§chlich reziprok (vgl. z.B. mit dem
Konzept der Meinungsf√ºhrer).

```{r Reziprozit√§t}
??reciprocity

#Reziprozit√§t f√ºr das Teilnetzwerk Zusammenarbeit berechnen 
reciprocity(work) #0.4736842, d.h. 47,37 Prozent aller Beziehungen im Netzwerk sind reziprok, hei√üt, 47,37 Prozent der Akteur*innen im Netzwerk haben angegeben, dass sie gerne miteinander zusammenarbeiten

#Reziprozit√§t f√ºr das Teilnetzwerk Ratsuche berechnen 
reciprocity(help) #0.2631579, d.h., 26,32 Prozent aller Beziehungen im Netzwerk sind reziprok, hei√üt, 26,32 Prozent der Akteur*innen im Netzwerk haben angegeben, dass sie einander um Rat fragen 


```

###Transitivit√§t 

Transitivit√§t ist eng mit Triaden oder "Tripletts" verbunden (vgl. z.B.
Hummel & Sodeur 2010).

**Transitivit√§t** beschreibt die M√∂glichkeit, dass zwischen Knoten
eine Weitergabe stattfindet
-->Transitivit√§t beschreibt den Hang der Knoten des Netzwerks, sich zu gruppieren. 
-->Je h√∂her die Transitivit√§t innerhalb des Netzwerks, desto mehr Gruppen sind vorhanden.
--> Streben nach ausgeglichenen Beziehungen 
--> wenn A und B jeweils mit C befreundet sind, ist die Wkeit hoch, dass A und B sich auch miteinander anfreunden

**Ergebnisse der Analyse** 

Bei der Transitivit√§t unterscheidet sich das Bild etwas: vor allem in
den Teilnetzwerken liegt eine Transitivit√§t mit jeweils 27% bei einem
Viertel der Beziehungen vor. Das bedeutet, dass hier eine triadische
Struktur vorliegt, bei der Inhalte weitergegeben werden.


```{r Transitivit√§t}
??transitivity

#Transitivit√§tswert f√ºr das Teilnetzwerk Zusammenarbeit berechnen 
transitivity(work) #0.2765957, also 27,66 Prozent der Beziehungen im Zusammenarbeitsnetzwerk streben nach Ausgeglichenheit --> Informationsaustausch / 27,66 Prozent der Akteur*innen im Zusammenarbeitsnetzwerk tauschen Informationen aus 

#Transitivit√§tswert f√ºr das Teilnetzwerk Ratsuche berechnen 
transitivity(help) #0.2716981, also 27,17 Prozent der Beziehungen im Ratsuchenetzwerk streben nach Ausgeglichenheit --> Informationsaustausch 27,17 Prozent der Akteur*innen im Ratsuchenetzwerk tauschen Informationen aus 


```

### Homophilie 

Die Homophilie untersucht die Struktur√§hnlichkeit von Knoten in
Netzwerken.

**Homophilie** betont die √Ñhnlichkeit von
Knoten.
--> gleich und gleich gesellt sich gern
--> Werte-Homophilie / Einstellungshomophilie: √Ñhnlichkeit in Werten und Weltanschauungen

igraph verwendet zur Berechnung von Homophilie den Wert **Assortivit√§t**: Dieser Wert gilt als positiv, wenn sich √§hnliche Knoten (aufgrund deren Eigenschaften) miteinander verbinden. Ansonsten wird der Wert negativ berechnet.
-->wenn **Wert** also **positiv** ist, dann **Homophilie**
-->wenn **Wert** also **negativ** ist, dann **keine Homophilie**

*Ergebnisse der Analyse*

Die Werte im Hauptnetzwerk nach Vertex-Attributen liegen alle unter 50%,
so dass nur eine schwache Form von Homophilie festgestellt werden kann. Das
gilt auch f√ºr die Teilnetzwerke Ratsuche und Zusammenarbeit. Gerade bei
Zusammenarbeit w√§re eine Homophilie zu vermuten gewesen.

```{r Homophilie}
# igraph verwendet zur Berechnung von Homophilie den Wert Assortivit√§t: Dieser Wert gilt als positiv, wenn sich √§hnliche Knoten (aufgrund deren Eigenschaften) miteinander verbinden. Ansonsten wird der Wert negativ berechnet.
#-->wenn Wert also positiv ist, dann Homophilie
#--> wenn Wert also negativ ist, dann keine Homophilie

??assortativity

#Vertex-Attribute anzeigen lassen
list.vertex.attributes(s)

# Assortivit√§t im Hauptnetzwerk

#Homophilie f√ºr das Geschlecht im gerichteten Netzwerk 
assortativity_nominal(s, V(s)$sex, directed=TRUE)
#0.107416, also haben 10,74 Prozent der Akteur*innen im Netzwerk das gleiche Geschlecht

#Homophilie f√ºr die Vertiefungsrichtung im gerichteten Netzwerk 
assortativity_nominal(s, V(s)$crpr, directed=TRUE)
#0.4358974, also haben 43,59 Prozent der Akteur*innen im Netzwerk die gleiche Vertiefungsrichtung

#Homophilie f√ºrs Rauchen im gerichteten Netzwerk 
assortativity_nominal(s, V(s)$smoke, directed=TRUE)
#0.1603053, also rauchen 16,03 Prozent der Akteur*innen im Netzwerk (zusammen) / also sind sich 6,03 Prozent der Akteur*innen im Netzwerk darin √§hnlich, dass sie rauchen 

#Homophilie daf√ºr, ob man ein Tattoo hat, im gerichteten Netzwerk
assortativity_nominal(s, V(s)$tatoo, directed=TRUE)
#-0.107438, also gibt es hier keine √Ñhnlichkeiten zwischen den Akteur*innen im Netzwerk. 

# Assortivit√§t im Teilnetzwerk Zusammenarbeit

#Homophilie f√ºr das Geschlecht im gerichteten Netzwerk 
assortativity_nominal(work, V(work)$sex, directed=TRUE)
#0.0970297, also haben 9,70 Prozent der Akteur*innen, die zusammenarbeiten, das gleiche Geschlecht

#Homophilie f√ºr die Vertiefungsrichtung im gerichteten Netzwerk
assortativity_nominal(work, V(work)$crpr, directed=TRUE)
#0.3233618, also arbeiten 32,34 Prozent der Akteur*innen bevorzugt mit Mitstudierenden aus der gleichen Vertiefungsrichtung zusammen

#Homophilie f√ºrs Rauchen im gerichteten Netzwerk 
assortativity_nominal(work, V(work)$smoke, directed=TRUE)
#0.09163347, also rauchen auch 9,16 Prozent der Akteur*innen, die zusammenarbeiten, auch zusammen / sind sich darin √§hlich, dass sie rauchen 

#Homophilie daf√ºr, ob man ein Tattoo hat, im gerichteten Netzwerk
assortativity_nominal(work, V(work)$tatoo, directed=TRUE)
#-0.05976096, also liegt hier keine √Ñhnlichkeit vor

# Assortivit√§t im Teilnetzwerk Ratsuche

#Homophilie f√ºr das Geschlecht im gerichteten Netzwerk 
assortativity_nominal(help, V(help)$sex, directed=TRUE)
#0.2203024, also fragen 22,03 Prozent der Akteur*innen andere Akteur*innen um Rat, die das gleiche Geschlecht haben wie sie

#Homophilie f√ºr die Vertiefungsrichtung im gerichteten Netzwerk
assortativity_nominal(help, V(help)$crpr, directed=TRUE)
#0.3870968, also fragen 38,71 Prozent der Akteur*innen andere Akteur*innen um Rat, die die gleiche Vertiefungsrichtung haben wie sie 

#Homophilie f√ºrs Rauchen im gerichteten Netzwerk 
assortativity_nominal(help, V(help)$smoke, directed=TRUE)
#0.2116183, also fragen 21,16 Prozent der Akteur*innen andere Akteur*innen um Rat, die auch rauchen

#Homophilie daf√ºr, ob man ein Tattoo hat, im gerichteten Netzwerk
assortativity_nominal(help, V(help)$tatoo, directed=TRUE)
#-0.1343284, also liegt hier keine √Ñhnlichkeit vor


```


#Visualisierung 

F√ºr die abschlie√üende Visualisierung sollten Sie mindestens zwei
ausgew√§hlte Grafiken zeigen: ein Mal das Gesamtnetzwerk (ggf. mit
verschiedenen Unterteilungen) und dann mindestens ein spezifisches
Netzwerk, das f√ºr die Analyse besonders relevant ist. Besonders
aussagekr√§ftig werden die Analysen, wenn Netzwerke nach bestimmten Node-
oder Vertex-Attributen verglichen werden oder einzelne Ego-Netzwerke
analysiert werden. Achten Sie hier auch darauf, bestimmte
Zentralit√§tma√üe zu verwenden.

**Anmerkung** Hilfreiche Visualisierungstutorials gibt es hier

-   [Die Tutorials von K.
    Ognyanova](https://kateto.net/network-visualization)
-   [Network Visualization
    Cookbook](https://rstudio-pubs-static.s3.amazonaws.com/341807_7b9d1a4e787146d492115f90ad75cd2d.html)
-   [Dai Chizuka's
    Tutorial](https://dshizuka.github.io/networkanalysis/tutorials.html)
    

## Allgemeines Visualisierung Plots


```{r Einfache Visualisierung des erstellten Objekt, fig.height=4, fig.width=6}

#Basic basic Visualisierung 

plot(s, 
     main="Darstellung Gesamtnetzwerk Studis CR/PR",
     sub="Semesterverbund CR/PR")

#Einfache Visualisierung 

plot(s,
     asp=0, 
     layout=layout_with_kk,
     vertex.size=10,
     vertex.label=20,
     edge.arrow.size=.4,
     edge.color="black",
     main ="√úbersicht Gesamtnetzwerk")

#Umfangreichere Visualisierung 

#Vorbereitung 

# Gesamtnetzwerk erstellen
# Der Code wird hier nur eingef√ºgt, falls der Chunk sp√§ter alleine weiterverwendet wird.

library(igraph)

#Edgelist einlesen

el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen

nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen

edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-Objekt s

s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Edge-Attribute anzeigen lassen 

list.edge.attributes(s) #Edge-Attribute weight, realtion, complicated

# simplify Gesamtnetzwerk 
# Um die Ergebnisse der Gewichte nicht zu verf√§lschen, werden die Edge-Attribute relation und complicated gel√∂scht.

#(neue Netzwerke erstellen, aus denen die entsprechenden Edge-Attribute gel√∂scht sind) 
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
list.edge.attributes(ss) #jetzt nur noch Edge-Attribute weight und relation

# mit dem Befehl simplify() lassen sich Edge-Attribute wie das Gewicht zusammenfassen. Damit ist zwar nicht mehr nachvollziehbar, um welche Beziehung es sich handelt. Daf√ºr lassen sich die Beziehungsst√§rken aber besser abbilden. Dies ist sp√§ter f√ºr die Analyse von dyadischen Beziehungen wichtig.

is_simple(ss)
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
is_simple(s_sim) #jetzt vereinfachtes Netzwerk
s_sim

# die aggregierten Werte f√ºr weight von s_sim werden deutlich.
list.edge.attributes(s_sim)
edge.attributes(s_sim)$weight #nur das Edge-Attribut weight anzeigen lassen

# Hat das Netzwerk Componenten?
is_connected(s_sim) #FALSE, also keine Verbindungen --> Komponenten liegen vor 

plot(s_sim,
     asp=0,
     layout=layout_nicely,
     vertex.size=10,
     vertex.label.cex=1,
     vertex.frame.color=NA,
     edge.arrow.size=.3,
     edge.color="black",
     edge.width=E(s_sim)$weight/2, #halbiert den Wert der Gewichte, um eine bessere Darstellung zu erm√∂glichen
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     main = "Gesamtnetzwerk vereinfacht", 
      sub = "aggregierte Gewichte von Ratsuche und Zusammenarbeit",
      cex.main = 2, col.main= "orange",
      cex.sub = 1, font.sub = 3, col.sub = "black")


```


## Labels von Knoten

Man kann die Anzeige von Knotennamen ausblenden und wieder einblenden
--> **Labels** bedeutet die **Art der Beschriftung / Anzeige der Knoten**

###Labels von Knoten ein- und ausblenden

```{r Knoten Labels √§ndern oder auch nicht}
# man kann die Anzeige von Knotennamen ausblenden und wieder einblenden:

#zeigt keine labels an
V(s)$label <- NA
plot(s, main="Darstellung ohne Labels")

# zeigt wieder die Labels aus der Nodelist Name an
V(s)$label <- V(s)$name
plot(s, main ="Labels wieder hergestellt")

```
###Schriftgr√∂√üe anpassen

--> Anpassung **Schriftgr√∂√üe**: **cex.main**= numerischer Wert
--> Anpassung **Schriftfarbe**: **col.main**="Farbe aus R-Farbpalette"

```{r Titel hinzuf√ºgen}

par(mfrow=c(1,1))
# Anpassung Schriftgr√∂√üe: cex.main= numerischer Wert
# Anpassung Schriftfarbe: col.main="Farbe aus R-Farbpalette"


par(mfrow=c(1,1))
plot(s,layout=layout_nicely,
main="Mein Titel",
      cex.main=1,
      col.main="pink")


```

###Layout-Parameter festlegen

```{r Netzwerk entzerren }
# Netzwerk nochmals neu einlesen

#Edgelist einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(edges)

#Edge- und Nodelist zusammenf√ºhren als igraph-Objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

E(s) #Edgelist-Beziehungen anzeigen
V(s) #Nodelist-Angaben anzeigen

# layout parameter festlegen f√ºr Fruchterman-Rheingold

#Layout mit Fruchterman-Rheingold-Algorithmus 
l <- layout_with_fr(s)

#Parameter bestimmen
l <- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1)

#Visualisierung angepasst an Faktoren-Vergr√∂√üerung
par(mfrow=c(2,2), mar=c(1,1,1,1))
plot(s, rescale=F, layout=l*0.4, main="Faktor 0.4")
plot(s, rescale=F, layout=l*0.8, main="Faktor 0.8")
plot(s, rescale=F, layout=l*1.2, main="Faktor 1.2")
plot(s, rescale=F, layout=l*1.6, main="Faktor 1.6")


# Beste Visualisierung ist mit Faktor 1.2
par(mfrow=c(1,1), mar=c(1,1,1,1))
plot(s, rescale=F, layout=l*2, main="entzerrte Darstellung")

```


## Attribute dauerhaft festlegen

Achtung: diese Variablen sind **dauerhaft festgelegt** und m√ºssen
entsprechend ersetzt werden. 
-->**Allerdings √ºberschreiben die Plot-Befehle immer die vorher gesetzten Attribute**.

**Dauerhafte Visualisierung vs. plot**
--> *Definierte Attribute E(g) oder V(g) bleiben erhalten*
--> Im *plot()* Befehl angelegte *Parameter gelten nur f√ºr diese Visualisierung* und *ignorieren die dauerhaft angelegten Attribute, falls diese abweichen sollten*. 
-->**Regel: nur die Attribute dauerhaft setzen, die f√ºr alle gelten sollen**.

```{r Kanten dauerhaft ein Attribut zuweisen?, fig.height=6, fig.width=10, message=FALSE, warning=FALSE, paged.print=FALSE}

# Sie k√∂nnen dauerhaft neue Edge-Attribute hinzuf√ºgen. Diese werden dann bei jeder Visualisierung aufgerufen. Eine Liste der Visualisierungsattribute gibt es unter https://igraph.org/r/doc/plot.common.html

list.edge.attributes(s) #weight, relation, complicated
E(s)$arrow.size <- .2 # definiert die Pfeilspitze dauerhaft auf Gr√∂√üe .2
E(s)$color <- "gray80" # definiert die Farbe dauerhaft (80% Grau) f√ºr alle Kanten
E(s)$curved <- .2 # definiert dauerhaft die Kr√ºmmung der Kanten
list.edge.attributes(s) # zeigt die neu definierten Attribute an.
#weight, relation, complicated, arrow.size, color, curved --> sind jetzt als Edge-Attribute angelegt 

#Visualisierung 
plot(s,
     asp=0,
     vertex.size=6)
```


##Einzelne Knoten beonders hervorheben

```{r Einzelne Knoten besonders herausheben, z.B. durch Rahmenfarbe}

# Wir wollen den Knoten mit dem h√∂chsten degree-Wert dauerhaft hervorheben.

# Berechnung indegree
s_deg <- degree(s, mode="in")
s_deg

# Welcher Knoten hat den h√∂chsten Indegree-Wert?
which.max(degree(s)) #Knoten 18

# Dauerhafte Markierung des Knoten 18 (in diesem Fall wird die Rahmenfarbe rot gesetzt)
V(s)[V(s)$name == 18]$frame.color <- "red"

plot(s, 
     layout = layout_with_fr,
     main="Rahmenfarbe f√ºr den h√∂chsten Degree hervorgehoben")

```
##Nachbarknoten farbig hervorheben

Mit dem Befehl **neighbors** lassen sich die angrenzenden Knoten anzeigen

```{r Nachbarknoten farbig markieren}
# Mit dem Befehl neighbors lassen sich die angrenzenden Knoten anzeigen

# w√§hlt die Nachbarn um Knoten 18 aus
n18 <- neighbors(s, V(s)[name=="18"], mode="all")

# definiert, welche Farben f√ºr die Knoten verwendet werden sollen
# vcol f√ºr n18 definiert die Farbe, die die Nachbarn von Knoten 18 erhalten sollen
vcol <- rep("lightblue", vcount(s)) #sonstige Nachbarn sind hellblau
vcol[n18] <- "blue" #direkte Nachbarn sind dunkelblau

# Gibt die Grafik mit den Nachbarknoten aus
plot(s, 
     layout=layout_with_fr,
     vertex.color=vcol, main="Nachbarknoten von 18")

```

## Gesamtnetzwerk

###Visualisierung nach Komponenten im Gesamtnetzwerk

```{r Visualisierung Gesamtnetzwerk , fig.height=8, fig.width=12, message=FALSE, warning=FALSE}

#Vorbereitung 

library(igraph)

#Edgelist einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen 
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren zum igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Edge-Attribute anzeigen lassen 
list.edge.attributes(s) #weight, relation, complicated

#Attribute, die wir f√ºr unsere Analyse nicht unbedingt brauchen, k√∂nnen wir l√∂schen
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")

#Vereinfachung des Netzwerkes
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))

# Visualisierung 

#Plotting 

# definiert die R√§nder (unten, links, oben, rechts)
par(mar=c(10,1,8,1)) 

plot(s_sim,
     asp=0,
     layout=layout_nicely,
     vertex.size=degree(s_sim, mode="all"), # Knotengr√∂√üe orientiert sich an Degree-Wert
     vertex.label.cex=2,
     vertex.frame.color=NA,
     edge.arrow.size=.7,
     edge.color="black",
     edge.width=E(s_sim)$weight/2, #halbiert den Wert der Gewichte, um eine bessere Darstellung zu erm√∂glichen
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     main = "Gesamtnetzwerk vereinfacht", 
      sub = "aggregierte Gewichte von Ratsuche und Zusammenarbeit",
      cex.main = 3, col.main= "orange",
      cex.sub = 2, font.sub = 3, col.sub = "black")

par(mar=c(2,2,2,2)) 

```

###Visualisierung nach Farbverl√§ufen: Bsp. Ratsuche  

```{r Visualisierung von Farbverl√§ufen von Werten, fig.height=8, fig.width=12, message=FALSE, warning=FALSE, paged.print=FALSE}

#Vorbereitung 

library(igraph)

#Edgelist einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen 
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen 
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s 
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Edge-Attribute anzeigen lassen 
list.edge.attributes(s) #weight, relation, complicated 

#Edge-Attribute, die wir f√ºr unsere Analyse nicht unbedingt brauchen, k√∂nnen wir auch l√∂schen
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")

#Vereinfachung des Netzwerkes 
s <- simplify(ss,edge.attr.comb=list(weight="sum"))

# Berechnung des Indegree-Werts normalisiert, also die prozentualen Indegree-Werte 
ins <- degree(s, mode = "in", normalized = TRUE)
ins #jetzt werden in der Konsole die jeweiligen Knoten mit ihren Indegree-Werten angezeigt 

#Visualisierung nach Farbverl√§ufen  

# legt die Farbskala fest zur Visualisierung
palette = colorRampPalette(c('lightblue','darkblue')) #Farbverlauf von hell- bis dunkelblau 

# die Palette wird in 10 Schritte unterteilt.
fine = 10
graphCol = palette(fine)[as.numeric(cut(ins, breaks = fine))] 

# der folgende Plot ist um einige weitere Visualisierungsparameter erg√§nzt

par(mar=c(10,1,10,1))

plot(s, 
     asp=0,
     rescale=TRUE,
     layout=layout_nicely,
     vertex.color=graphCol, #verwende als Farbe die Farbpalette 
     vertex.label=NA,
     vertex.size=6, # hier k√∂nnte auch die Gr√∂√üe der indegrees gesetzt werden
     vertex.frame.color = "white", 
     edge.color="lightblue", 
     edge.width=E(s_sim)$weight/2, #Gewicht halbiert f√ºr bessere Darstellung
     edge.curved=.2,
     edge.curved=curve_multiple(s),
     main = "Wer wird um Rat gefragt? (n=38)", 
      sub = "Visualisierung nach normalisierter Indegree-Verteilung",
      cex.main = 2, col.main= "darkblue", #besonders wichtige Knoten in dunkelblau, cex.main sorgt daf√ºr, dass Titel in doppelter Schriftgr√∂√üe als der Standard angezeigt wird
      cex.sub = 2, font.sub = 3, col.sub = "black") #Gr√∂√üen- & Farbangaben Untertitel

```

### Visualisierung Gesamtnetzwerk nach Node-Attribut: 

**Bsp.:Vertiefung und Geschlecht nach Farben und Formen**

```{r Geschlechtsverteilung, fig.height=8, fig.width=10, message=FALSE, warning=FALSE, paged.print=FALSE}

#Vorbereitung 

library(igraph)

#Edgelist einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Edge-Attribute anzeigen lassen
list.edge.attributes(s) #weight, relation, complicated

#(Edge-Attribute, die wir f√ºr unsere Analyse nicht brauchen, k√∂nnen wir auch l√∂schen) 
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")

#(Vereinfachung Netzwerk)
s <- simplify(ss,edge.attr.comb=list(weight="sum"))

# Farben und Formen setzen

# weist den Attributswerten entsprechende Farben zu
V(s)[V(s)$sex == 1]$color <- "pink" #Frauen pink 
V(s)[V(s)$sex == 2]$color <- "lightblue" #M√§nner hellblau 
V(s)[V(s)$sex == 3]$color <- "lightgreen" #divers gr√ºn 


#Node-Attribut crpr anzeigen
vertex.attributes(s)$crpr


# weist den Attributswerten der Vertiefung entsprechende Formen zu
#Node-Attribut Vertiefungsrichtung ausw√§hlen und Form festlegen
V(s)[V(s)$crpr == 1]$shape <- "square"  #Rechteck 
V(s)[V(s)$crpr == 2]$shape <- "circle"  #Kreis 


# definiert die R√§nder (unten, links, oben, rechts)
par(mar=c(12,1,8,1)) 

plot(s,
     asp=0,
     layout=layout_nicely,
     vertex.size=degree(s, mode="all"), # Knotengr√∂√üe richtet sich nach Degree-Wert
     vertex.frame.color=NA,
     vertex.size=7,
     vertex.label.cex=1,
     vertex.label.color="black",
     edge.arrow.size=.7,
     edge.color="gray20",
     edge.width=E(s_sim)$weight/2, #halbiert den Wert der Gewichte, um eine bessere Darstellung zu erm√∂glichen
     edge.curved=.2,
     edge.curved=curve_multiple(s),
     main = "Gesamtnetzwerk: Vertiefung und Geschlecht", 
      sub = "Vertiefung und Geschlecht",
      cex.main = 2, col.main= "black",
      cex.sub = 2, font.sub = 3, col.sub = "black")

par(mar=c(2,2,2,2)) 


```

### Visualisierung und Veranschaulichung multiplexes Netzwerk

####Kantenfarben

Um das etwas √ºbersichtlicher darzustellen, bietet sich bei einem
**Netzwerk mit verschiedenen Beziehungsarten** an, diese farblich zu
unterscheiden.
--> **multiples Netzwerk** bedeutet also, dass man **verschiedene Beziehungsarten** betrachtet 
--> dabei wird jede Beziehungsart f√ºr sich analysiert 
--> anhand dieser Analyse k√∂nnen R√ºckschl√ºsse auf die Wechselwirkungen zwischen den Knoten gezgogen werden, also z.B. gibt es einen Zusammmenhang zwischen Ratsuche und Zusammenarbeit (zwei verschiedene Beziehungsarten) in einem Netzwerk?

-->**Multiplexe Netzwerke** haben **mehr als nur eine Kantenart**, d.h. es werden **mehrere Beziehungsarten im gleichen Graphen visualisiert**. 
-->Dazu gibt es zwei M√∂glichkeiten (die sich auch kombinieren lassen): Farben und Formen. 
-->Achtung: multiplexe Netzwerke werden leicht un√ºbersichtlich, deshalb sollte die Visualisierung immer mit Bedacht vorgenommen werden.

*Kantenfarben* verwenden: wir haben in dem Edge-Attribut "relation" zwei Werte angebgeben, n√§mlich "1" (work) und "2" (help), die unterschiedliche Beziehungen beschreiben. Die Kanten lassen sich entsprechend einf√§rben.


```{r Visualisierung eines multiplexe Netzwerke erstellen, fig.height=8, fig.width=10}

#Vorbereitung 

library(igraph)

#Edgelist einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# Farbe der Relationen festlegen 
E(s)[E(s)$relation == 1]$color <- "blue" #Zsmarbeit
E(s)[E(s)$relation == 2]$color <- "darkgreen" #Ratsuche 
E(s)[E(s)$relation == 3]$color <- "red" #Beziehung 


# Visualisierung


# Visualisierungsparameter festlegen
par(mar=c(6,3,3,3)) 

# Plot mit den gesetzten Farben f√ºr das Attribut Beziehung realisieren
plot(s,
     asp=0,
     edge.arrow.size=.5,
     vertex.color="gray75",
     vertex.frame.color="NA",
     vertex.size=8,
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Multiplexes Netzwerk, d.h. verschiedene Formen der Beziehung",
     sub="n=38 Knoten; Kantenfarbe 
     blau=Zusammenarbeit, gr√ºn=Ratsuche, rot=Beziehung")

par(mar=c(0,0,0,0)) 
# setzt die Seitenaufteilung zur√ºck
par(mfrow=c(1,1), mar=c(2,0,2,0)) 

```
####Kantenformen

*Kantenformen* verwenden: Neben den Vertex-Formaten lassen sich auch die Kanten visuell anpassen. 
-->Hier stehen verschiedene Formen zur Verf√ºgung: 
-->**0 or ‚Äúblank‚Äù**, -->keine Hervorhebung Kante 
-->**1 or ‚Äúsolid‚Äù**, -->durchgezogene Kantenlinie 
-->**2 or ‚Äúdashed‚Äù**, -->gestrichelt 
-->**3 or ‚Äúdotted‚Äù**, -->gepunktet 
-->**4 or ‚Äúdotdash‚Äù**, -->gestrichelt & gepunktet /punktgestrichelt
-->**5 or ‚Äúlongdash‚Äù**, -->langgestrichelt
-->**6 or ‚Äútwodash‚Äù**. -->doppelt gestrichelt 
-->Die Codierung ist vorgegeben und als edge.lty definiert. **lty** steht f√ºr Linetype, also die **Art der Linie, die verwendet wird**.

```{r Multiplex Kantenformen}

#verschiedene Kantenformen

E(s)[E(s)$relation == 1]$lty <-2 # dashed (work) #gestrichelt
E(s)[E(s)$relation == 2]$lty <-3 # dotted (help) #gepunktet
E(s)[E(s)$relation == 3]$lty <-4 # dotdash (love) #punktgestrichelt

# Visualisierung des multiplexen Netzwerks
plot(s,
     asp=0,
     edge.arrow.size=.2,
     edge.color="black",
     vertex.color="gray90",
     vertex.frame.color="white",
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Multiplexes Netzwerk, Format der Kanten",
     sub="n=38, work=dashed, help=dotted, love=dotdash")

```



###Drei Netzwerke in einer Zeile: Visualisierung von Teilnetzwerken im Vergleich 

**Drei Netzwerke in einer Ziele**
--> damit die drei Netzwerke in einer Zeile angezeigt werden, muss man diesen *Befehl & die Plots gleichzeitig markieren & runnen*
--> sonst werden die Plots n√§mlich einzeln angezeigt

```{r Teilnetzwerke im Vergleich, fig.height=6, fig.width=9, message=FALSE, warning=FALSE, paged.print=FALSE}

#Vorbereitung

library(igraph)

#Edgelist einlesen
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")

#Nodelist einlesen 
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

#Edgematrix erstellen 
edgematrix <-as.matrix(el)

#Edge- und Nodelist zusammenf√ºhren als igraph-objekt s 
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

#Visualisierung 

# definiert die Farbe der Relation
E(s)[E(s)$relation == 1]$color <- "blue"      #Zusammenarbeit
E(s)[E(s)$relation == 2]$color <- "darkgreen" #Ratsuche 
E(s)[E(s)$relation == 3]$color <- "red"       #Beziehung

# erstellt die Teilnetzwerke 

#Teilnetzwerk Zusammenarbeit
work <- subgraph.edges(s, E(s)[relation==1]) 

#Teilnetzwerk Ratsuche
help <- subgraph.edges(s, E(s)[relation==2])

#Teilnetzwerk Beziehung
love <- subgraph.edges(s, E(s)[relation==3])

# Drei Netzwerke in einer Ziele
#damit die drei Netzwerke in einer Zeile angezeigt werden, muss man diesen Befehl & die Plots gleichzeitig markieren & runnen
#sonst werden die Plots n√§mlich einzeln angezeigt

# Drei Teilnetzwerke nacheinander plotten, diese werden dann in einer Zeile dargestellt

par(mfrow=c(1,3), mar=c(2,0,2,0)) 
plot(work,
     asp=0,
     edge.arrow.size=.5,
     vertex.color="gray75",
     vertex.frame.color="NA",
     vertex.size=8,
     layout=layout_with_kk,
     edge.curved=curve_multiple(work),
     main="Teilnetzwerk Work",
     sub="n=38 Knoten; Kantenfarbe blau"
     )

plot(help,
     asp=0,
     edge.arrow.size=.5,
     vertex.color="gray75",
     vertex.frame.color="NA",
     vertex.size=8,
     layout=layout_with_kk,
     edge.curved=curve_multiple(help),
     main="Teilnetzwerk Help",
     sub="n=38 Knoten; Kantenfarbe gr√ºn",
)
     
plot(love,
     asp=0,
     edge.arrow.size=.5,
     vertex.color="gray75",
     vertex.frame.color="NA",
     vertex.size=8,
     layout=layout_with_kk,
     edge.curved=curve_multiple(love),
     main="Teilnetzwerk Love",
     sub="n=38 Knoten; Kantenfarbe gr√ºn"
)


# setzt die Seitenaufteilung zur√ºck
par(mfrow=c(1,1), mar=c(2,0,2,0)) 

```


### Visualisierung mit angezeigten Namen: Bsp. Teilnetzwerk Beziehung 

-->anstatt der Knoten sollen in der Visualisierung des Netzwerks jetzt die **Vornamen** angezeigt werden

```{r Paarbeziehungen mit Namen im Label, fig.height=6, fig.width=10}

# Zeige die Vertex-Attribute
list.vertex.attributes(love)

# Wir zeigen die Vornamen aus den Paarbeziehungen an
vertex.attributes(love)$name_first

# wir √ºberschreiben den angezeigten label mit den Werten aus name_first -->damit ab jetzt Name anstatt ID als Label angezeigt wird 
V(love)$label <- V(love)$name_first

#die Geschlechter farblich unterscheiden
V(love)[V(love)$sex == 1]$label.color <- "red"      #Frauen 
V(love)[V(love)$sex == 2]$label.color <- "blue"      #M√§nner 
V(love)[V(love)$sex == 3]$label.color <- "darkgreen" #divers

plot(love, 
		 asp=0,
		 vertex.shape="none", 
		 vertex.label=love$name_first,
		 # vertex.label.color="black",
		 vertex.label.font=1, 
     vertex.label.cex=3, 
		 edge.color="black",  
		 edge.width=3,
		 main="Liebes-Netzwerk mit Vornamen")
 
```

#Zusatz: Analyse √ºber mehrere Jahresangaben hinweg (Apollo-L√∂sung Sandhu ausf√ºhrliche zweite Version)

##Netzwerk Apollo Vorbereitung

```{r Setup Apollo, include=FALSE}

# Diesen Chunk nicht ver√§ndern
knitr::opts_chunk$set(echo = TRUE)
set.seed=123

# Programmbibliotheken laden
library(tidyverse)
library(igraph)

#Datensatz einlesen

# Edgelist einlesen 
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/apollo50years/ap50_edges.csv", header=T, as.is=T, sep = ",")

# Nodelist einlesen
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/apollo50years/ap50_nodes.csv", header=T, as.is=T, sep = ",")

# Edgematrix erstellen
edgematrix <-as.matrix(el)

# Edge- und Nodelist zusammenf√ºhren als igraph-objekt a f√ºr apollo
a <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
a #89 Knoten und 210 Kanten 

```
##Zeitspanne analysieren

Als n√§chstes interessieren wir uns f√ºr eine zeitliche Abfolge der tats√§chlichen Fl√ºge, beginnend 1962 mit den bemannten Fl√ºgen des Mercury-Programms bis 1972 mit dem letzten Flug zum Mond durch Apollo 17. 

-->**funktioniert eigentlich ganz normal mit Funktion subgraph.eges, um Teilnetzwerk nach Edge-Attributen zu erstellen**

```{r Sequencing the manned flights by year}

# Wir werden f√ºr diese Analyse nur die Flug- und Ersatzmannschaften betrachten:
a_fb <- subgraph.edges(a, E(a)[role <= 2])
a_fb # apollo flight and backup crews
     #75 Knoten, 136 Kanten

#Teilnetzwerke erstellen 

#Teilnetzwerk f√ºr das Jahr 1961
y1961 <- subgraph.edges(a_fb, E(a_fb)[year==1961])
y1961 #5 Knoten & 3 Kanten --> 5 Astronaut*innen waren 1961 auf dem Mond 

#Teilnetzwek f√ºr 1962
y1962 <- subgraph.edges(a_fb, E(a_fb)[year==1962])
y1962 #8 Knoten & 7 Kanten --> 8 Astronaut*innen waren 1962 auf dem Mond 

#Teilnetzwek f√ºr 19623
y1963 <- subgraph.edges(a_fb, E(a_fb)[year==1963])
y1963 #2 Knoten & 1 Kante --> 2 Astronaut*innen waren 1963 auf dem Mond 

#Teilnetzwek f√ºr 1965
y1965 <- subgraph.edges(a_fb, E(a_fb)[year==1965])
y1965 #18 Knoten & 20 Kanten --> 18 Astronaut*innen waren 1965 auf dem Mond 

#Teilnetzwek f√ºr 1966
y1966 <- subgraph.edges(a_fb, E(a_fb)[year==1966])
y1966 #19 Knoten & 20 Kanten --> 19 Astronaut*innen waren 1966 auf dem Mond 

#Teilnetzwek f√ºr 1967
y1967 <- subgraph.edges(a_fb, E(a_fb)[year==1967])
y1967

#Teilnetzwek f√ºr 1968
y1968 <- subgraph.edges(a_fb, E(a_fb)[year==1968])
y1968 #10 Knoten & 9 Kanten --> 10 Astronaut*innen waren 1968 auf dem Mond 

#Teilnetzwek f√ºr 1969
y1969 <- subgraph.edges(a_fb, E(a_fb)[year==1969])
y1969 #24 Knoten & 24 Kanten --> 24 Astronaut*innen waren 1969 auf dem Mond 

#Teilnetzwek f√ºr 1970
y1970 <- subgraph.edges(a_fb, E(a_fb)[year==1970])
y1970 #7 Knoten & 6 Kanten --> 7 Astronaut*innen waren 1970 auf dem Mond 

#Teilnetzwek f√ºr 1971
y1971 <- subgraph.edges(a_fb, E(a_fb)[year==1971])
y1971 #14 Knoten & 12 Kanten --> 7 Astronaut*innen waren 1971 auf dem Mond

#Teilnetzwek f√ºr 1972
y1972 <- subgraph.edges(a_fb, E(a_fb)[year==1972])
y1972 #13 Knoten & 13 Kanten --> 13 Astronaut*innen waren 1970 auf dem Mond

#Visualisierung

par(mfrow=c(3,4), mar=c(0,0,1,2))

plot(y1961, edge.arrow.size=.2, main="1961")
plot(y1962, edge.arrow.size=.2, main="1962")
plot(y1963, edge.arrow.size=.2, main="1963")
plot(y1965, edge.arrow.size=.2, main="1965")
plot(y1966, edge.arrow.size=.2, main="1966")
plot(y1967, edge.arrow.size=.2, main="1967")
plot(y1968, edge.arrow.size=.2, main="1968")
plot(y1969, edge.arrow.size=.2, main="1969")
plot(y1970, edge.arrow.size=.2, main="1970")
plot(y1971, edge.arrow.size=.2, main="1971")
plot(y1972, edge.arrow.size=.2, main="1972")

```




